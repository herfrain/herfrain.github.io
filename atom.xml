<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随峰而动</title>
  
  <subtitle>Herfrain</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-31T10:25:40.022Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Herfrain</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux常见命令</title>
    <link href="http://example.com/2022/07/26/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/07/26/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-26T08:19:04.000Z</published>
    <updated>2022-10-31T10:25:40.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件目录管理命令">1. 文件目录管理命令</h1><h1 id="打包压缩命令">2. 打包压缩命令</h1><p>tar命令对文件进行打包压缩或解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tar [参数] [文件]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数</span></span><br><span class="line">-c # 创建压缩文件</span><br><span class="line">-x # 解开压缩文件</span><br><span class="line">-t # 查看压缩包内的文件</span><br><span class="line">-z # 用Gzip压缩或解压</span><br><span class="line">-j # 用bzip2压缩或解压</span><br><span class="line">-v # 显示压缩或解压的过程</span><br><span class="line">-f # 目标文件名，放在参数最后一位，代表压缩或解压的文件名</span><br><span class="line">-p # 保留原始的权限与属性</span><br><span class="line">-P # 使用绝对路径来压缩</span><br><span class="line">-C # 指定解压的路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用Gzip压缩和解压</span></span><br><span class="line">tar -czvf 目标文件.tar.gz 源文件</span><br><span class="line">tar -xzvf 目标文件.tar.gz -C 解压路径</span><br></pre></td></tr></table></figure><h1 id="搜索命令">3. 搜索命令</h1><p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep [参数] [关键词] [文件]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数</span></span><br><span class="line">-b # 将可执行文件(binary)当作文本文件(text)来搜索</span><br><span class="line">-c # 仅显示找到的行数</span><br><span class="line">-i # 忽略大小写</span><br><span class="line">-n # 显示行号</span><br><span class="line">-v # 反向选择，即列出没有关键词的行</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> eg</span></span><br><span class="line">grep -n /sbin/nologin /etc/passwd # 在/etc/passwd文件中，查找关键词&quot;/sbin/nologin&quot;，并显示行号</span><br></pre></td></tr></table></figure><p>find命令用于按照指定条件来查找文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [查找路径] [参数] [操作]</span><br></pre></td></tr></table></figure><h1 id="重定向">4. 重定向</h1><p>重定向：输入重定向，输出重定向</p><p>写入内容：标准，错误</p><p>写入方式：清空写入，追加写入</p><h2 id="输入重定向">4.1. 输入重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件 # 将文件作为命令的标准输入</span><br><span class="line">命令 &lt;&lt; 分界符 # 从标准输入中读取，直到遇见分界符才停止</span><br><span class="line">命令 &lt;文件1&gt; 文件2 # 将文件1作为命令的标准输入，文件2作为标准输出</span><br></pre></td></tr></table></figure><h2 id="输出重定向">4.2. 输出重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件 # 将标准输出重定向到一个文件中（清空写入）</span><br><span class="line">命令 2&gt; 文件 # 将错误输出重定向到一个文件中（清空写入）</span><br><span class="line">命令 &gt;&gt; 文件 # 将标准输出重定向到一个文件中（追加写入）</span><br><span class="line">命令 2&gt;&gt; 文件 # 将错误输出重定向到一个文件中（追加写入）</span><br><span class="line">命令 &amp;&gt;&gt; 文件 # 将标准输出和错误输出一起写到文件中（追加写入）</span><br></pre></td></tr></table></figure><h1 id="管道命令符">5. 管道命令符</h1><p>将前一个命令的输出当做后一个命令的输入，可用多个管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令A | 命令B | 命令C | ...</span><br></pre></td></tr></table></figure><p>使用more查看&#x2F;etc目录文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc | more</span><br></pre></td></tr></table></figure><p>修改root的密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;xxxx&quot; | passwd --stdin root</span><br></pre></td></tr></table></figure><p>向其他用户发送邮件，将标题和内容一起打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo “内容” | mail -s &quot;标题&quot; 用户名</span><br></pre></td></tr></table></figure><p>使用mail发送邮件，遇到分界符’over’时停止输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mail -s &quot;标题&quot; 用户名 &lt;&lt; over</span><br><span class="line">xxxxxxxx</span><br><span class="line">xxxx</span><br><span class="line">xx</span><br><span class="line">over</span><br></pre></td></tr></table></figure><h1 id="通配符">6. 通配符</h1><ul><li>*：匹配0个或多个字符</li><li>?：匹配任意1个字符</li><li>[0-9]：匹配0~9的单个字符</li><li>[abc]：匹配{a,b,c}中的单个字符</li></ul><p>查看所有在&#x2F;dev目录中以sda开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/sda*</span><br></pre></td></tr></table></figure><h1 id="转义字符">7. 转义字符</h1><ul><li>反斜杠\：使后面的一个变量变成单纯的字符串</li><li>单引号’’：转义其中的变量为单纯的字符串</li><li>双引号””：保留变量属性，不转义</li><li>反引号&#96;&#96;：把其中的命令执行后返回结果</li></ul><h1 id="环境变量">8. 环境变量</h1><table><thead><tr><th>环境变量名</th><th>作用</th></tr></thead><tbody><tr><td>HOME</td><td>用户主目录（家目录）</td></tr><tr><td>SHELL</td><td>用户使用的Shell解释器名称</td></tr><tr><td>HISTSIZE</td><td>输出的历史命令记录条数</td></tr><tr><td>HISTFILESIZE</td><td>保存的历史命令记录条数</td></tr><tr><td>MAIL</td><td>邮件保存路径</td></tr><tr><td>LANG</td><td>系统语言</td></tr><tr><td>RANDOM</td><td>随机数字</td></tr><tr><td>PS1</td><td>Bash解释器的提示符</td></tr><tr><td>PATH</td><td>定义解释器搜索用户执行命令的路径</td></tr><tr><td>EDITOR</td><td>默认文本编辑器</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件目录管理命令&quot;&gt;1. 文件目录管理命令&lt;/h1&gt;&lt;h1 id=&quot;打包压缩命令&quot;&gt;2. 打包压缩命令&lt;/h1&gt;&lt;p&gt;tar命令对文件进行打包压缩或解压&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="命令" scheme="http://example.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见指令</title>
    <link href="http://example.com/2022/07/06/MySQL%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2022/07/06/MySQL%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/</id>
    <published>2022-07-06T09:54:20.000Z</published>
    <updated>2022-10-31T10:25:40.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本操作">1. 基本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接远程服务器的MySQL</span></span><br><span class="line">mysql -u ip地址 -P 端口 -u 用户名 -p 密码;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 显示线程</span><br><span class="line">SHOW PROCESSLIST;</span><br><span class="line"># 显示系统变量</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure><h1 id="数据库操作">2. 数据库操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前数据库</span><br><span class="line">SELECT DATABASE();</span><br><span class="line"># 显示当前时间、用户名、数据库版本</span><br><span class="line">SELECT now(), user(), version();</span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 选项</span><br><span class="line">选项：</span><br><span class="line">- CHARACTER SET 字符集名</span><br><span class="line">- COLLATE 校对名</span><br><span class="line"># 显示已创建的数据库列表</span><br><span class="line">SHOW DATABASES [LIKE &#x27;PATTERN&#x27;]</span><br><span class="line"># 查看数据库信息</span><br><span class="line">SHOW CREATE DATABASE 数据库名</span><br><span class="line"># 修改数据库选项</span><br><span class="line">ALTER DATABASE 数据库名 选项</span><br><span class="line"># 删除数据库</span><br><span class="line">DROP DATABASE [IF EXISTS] 数据库名</span><br></pre></td></tr></table></figure><h1 id="表操作">3. 表操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line">CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [库名.]表名 (表的结构定义)[表选项]</span><br><span class="line">表的结构定义：字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &#x27;string&#x27;]，多个字段用逗号隔开</span><br><span class="line">表选项（多个表选项之间用空格隔开）：</span><br><span class="line">- CHARSET = charset_name # 字符集（如果表没有设定，则使用数据库字符集）</span><br><span class="line">- ENGINE = engine_name # 存储引擎（包括InnoDB、MyISAM、Memory/Heap、BDB、Merge、Example、CSV、MaxDB、Archive等）</span><br><span class="line">- AUTO_INCREMENT = 行数 # 自增起始数</span><br><span class="line">- DATA DIRECTORY = &#x27;目录&#x27; # 数据文件目录</span><br><span class="line">- INDEX DIRECTORY = &#x27;目录&#x27; # 索引文件目录</span><br><span class="line">- COMMENT = &#x27;string&#x27; # 表注释</span><br><span class="line">- PARTITION BY ... # 分区选项</span><br><span class="line"># eg</span><br><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"># 查看表信息</span><br><span class="line">SHOW TABLES [LIKE &#x27;pattern&#x27;]</span><br><span class="line">SHOW TABLES FROM 库名</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">SHOW CREATE TABLE 表名</span><br><span class="line">DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#x27;PATTERN&#x27;]</span><br><span class="line">SHOW TABLE STATUS [FROM db_name] [LIKE &#x27;pattern&#x27;]</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line">## 修改表本身的选项</span><br><span class="line">ALTER TABLE 表名 表的选项</span><br><span class="line">eg: ALTER TABLE 表名 ENGINE=MYISAM;</span><br><span class="line">## 对表重命名</span><br><span class="line">RENAME TABLE 原表名 TO [库名.]新表名</span><br><span class="line">## 修改表的字段机构</span><br><span class="line">ALTER TABLE 表名 操作名</span><br><span class="line">操作名：</span><br><span class="line">- ADD [COLUMN] 字段定义 # 增加字段</span><br><span class="line">    - AFTER 字段名 # 表示增加在该字段名后面</span><br><span class="line">    - FIRST # 表示增加在第一个</span><br><span class="line">    - ADD PRIMARY KEY(字段名) # 创建主键</span><br><span class="line">    - ADD UNIQUE [索引名] (字段名) # 创建唯一索引</span><br><span class="line">    - ADD INDEX [索引名] (字段名) # 创建普通索引</span><br><span class="line">    - DROP [COLUMN] 字段名 # 删除字段</span><br><span class="line">    - MODIFY [COLUMN] 字段名 字段属性 # 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">    - CHANGE[ COLUMN] 原字段名 新字段名 字段属性 # 支持对字段名修改</span><br><span class="line">    - DROP PRIMARY KEY # 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">    - DROP INDEX 索引名 # 删除索引</span><br><span class="line">    - DROP FOREIGN KEY 外键 # 删除外键</span><br><span class="line">## 删除表</span><br><span class="line">DROP TABLE [IF EXISTS] 表名 ...</span><br><span class="line">## 清空表数据</span><br><span class="line">TRUNCATE [TABLE] 表名</span><br><span class="line">## 复制表结构</span><br><span class="line">CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">## 复制表结构和数据</span><br><span class="line">CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">## 检查表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">## 优化表</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">## 修复表</span><br><span class="line">REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">## 分析表</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h1 id="数据操作">4. 数据操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 增</span><br><span class="line">INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br><span class="line"># 删</span><br><span class="line">DELETE FROM 表名 [删除条件子句]</span><br><span class="line"># 改</span><br><span class="line">UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</span><br><span class="line"># 查</span><br><span class="line">SELECT 字段列表 FROM 表名 [其他子句]</span><br></pre></td></tr></table></figure><h1 id="MySQL-函数">5. MySQL 函数</h1><h2 id="字符串函数">5.1. 字符串函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 返回字符串s的长度</span><br><span class="line">CHAR_LENGTH(s)</span><br><span class="line"># 连接字符串s1,s2,...,sn</span><br><span class="line">CONCAT(s1, s2...sn)</span><br><span class="line"># 以字符串x为连接符，连接s1...sn</span><br><span class="line">CONCAT_WS(x, s1,s2...sn)</span><br><span class="line"># s2是用逗号为分隔符的字符串集合，在s2中查找s1的首次出现的位置，0表示不存在</span><br><span class="line">FIND_IN_SET(s1, s2)</span><br><span class="line">SELECT FIND_IN_SET(&quot;c&quot;, &quot;a,b,c,d,e&quot;); # 3</span><br><span class="line"># 字符串s2替换s1[x, x + len - 1]</span><br><span class="line">INSERT(s1, x, len, s2)</span><br><span class="line"># 在字符串s中，找到子串s1的开始位置</span><br><span class="line">LOCATE(s1, s)</span><br><span class="line"># </span><br></pre></td></tr></table></figure><h2 id="高级函数">5.2. 高级函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 与switch功能相似</span><br><span class="line">CASE expression</span><br><span class="line">    WHEN condition1 THEN result1</span><br><span class="line">    WHEN condition2 THEN result2</span><br><span class="line">   ...</span><br><span class="line">    WHEN conditionN THEN resultN</span><br><span class="line">    ELSE result</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 若v1==null，返回v2，否则返回v1</span><br><span class="line">IFNULL(v1, v2)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本操作&quot;&gt;1. 基本操作&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>后端框架复习</title>
    <link href="http://example.com/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-07T11:07:40.000Z</published>
    <updated>2022-10-31T11:31:51.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC">1. SpringMVC</h1><p>MVC：Model模型, View视图, Controller控制器</p><p>核心思想：数据，视图和业务逻辑分离</p><h2 id="组件与流程">1.1. 组件与流程</h2><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/image-20220313161849703.png" class title="image-20220313161849703"><p><strong>1、前端控制器 DispatcherServlet（框架提供）</strong></p><p>Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器，减少了其它组件之间的耦合度。</p><p><strong>2、处理器映射器 HandlerMapping（框架提供）</strong></p><p>负责根据用户请求找到Handler。SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><strong>3、处理器适配器 HandlerAdapter（框架提供）</strong></p><p>按照特定规则（HandlerAdapter要求的规则）去执行Handler，通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p><strong>4、处理器 Handler（自己开发）</strong></p><p>编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 工程师根据业务需求开发Handler。</p><p><strong>5、视图解析器 View resolver（框架提供）</strong></p><p>进行视图解析，根据逻辑视图名解析成真正的视图（View）。View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p><strong>6、视图 View（自己开发）</strong></p><p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p><h1 id="SpringBoot">2. SpringBoot</h1><p>Spring框架是一个轻量级Java开发框架，简化了开发流程，提高了开发效率。它由许多模块组成，模块提供了很多方法，使得开发变得更加简单。</p><h2 id="模块与功能">2.1. 模块与功能</h2><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/e0c60b4606711fc4a0b6faf03230247a.png" class title="Spring主要模块"><blockquote><p>上图是Spring4.x版本，最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p></blockquote><h2 id="核心思想">2.2. 核心思想</h2><h3 id="IoC-控制反转">2.2.1. IoC 控制反转</h3><p>IoC（Inverse of Control，控制反转）：将对象的创建的权力交给框架来执行。</p><p>一般我们需要自己new对象来执行一些方法，当新增了一个新实现，我们就又要修改new的对象。有了控制反转，我们不用在我们使用之前，框架已经帮我们创建好了，并放在IoC容器中，我们可以直接从IoC容器中获取相应对象。</p><p>实现方式：DI（Dependency Injection，依赖注入）</p><h3 id="AOP-面向切面编程">2.2.2. AOP 面向切面编程</h3><p>AOP（Aspect Oriented Programming，面向切面编程）：在不改变原来业务逻辑的情况下，把横切逻辑与业务逻辑分离，减少横切逻辑代码的重复。这些横切逻辑一般是事务处理、日志管理、权限控制等，他们都是为业务逻辑服务的，是共同使用的功能，AOP就是要把这些功能与业务逻辑分离，减少耦合。</p><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/640.png" class title="图片"><h1 id="MyBatis">3. MyBatis</h1><h2 id="核心对象">3.1. 核心对象</h2><p>三个基本要素：</p><ul><li>核心接口和类</li><li>MyBatis核心配置文件（mybatis-config.xml）</li><li>SQL映射文件（mapper.xml）</li></ul><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/144422M58-0.png" class title="MyBatis核心对象"><p>每个 MyBatis 应用程序都以一个 SqlSessionFactory 对象的实例为核心。</p><p>首先获取 SqlSessionFactoryBuilder 对象，可以根据 XML 配置文件或者 Configuration 类的实例构建该对象。<br>然后获取 SqlSessionFactory 对象，该对象实例可以通过 SqlSessionFactoryBuilder 对象来获取。<br>有了 SqlSessionFactory 对象之后，就可以进而获取 SqlSession 实例。SqlSession 对象中完全包含以数据库为背景的所有执行 SQL 操作的方法，用该实例可以直接执行已映射的 SQL 语句。</p><h2 id="与">3.2. #与$</h2><p><code>#&#123;a&#125;</code>：MyBatis 会将 sql 中的 <code>#&#123;a&#125;</code>替换为 <code>? </code>号<br>如 <code>select * from admin where id = #&#123;id&#125;</code>-&gt;<code>select * from admin where id = ?</code>，在sql执行前会按序给 <code>?</code>赋值<br><strong>作用：预编译，防止sql注入</strong></p><p><code> $&#123;a&#125;</code>：不会将a当做字符串处理，原来值是什么就是什么，直接静态文本替换<br>如id的值为2，则 <code>select * from admin where id = $&#123;id&#125;</code>-&gt;<code>select * from admin where id = 2</code><br>如id的值为id，可以用于 <code>select * from admin order by $&#123;id&#125;</code>-&gt;<code>select * from admin order by id</code></p><p>一般能用 <code>#&#123;&#125;</code>就用这个</p><h2 id="缓存">3.3. 缓存</h2><p>MyBatis 提供了一级缓存和二级缓存的支持。默认情况下，MyBatis 只开启一级缓存。</p><h3 id="一级缓存">3.3.1. 一级缓存</h3><p>一级缓存是基于 PerpetualCache（MyBatis自带）的 HashMap 本地缓存，作用范围为 session 域内。当 session flush（刷新）或者 close（关闭）之后，该 session 中所有的 cache（缓存）就会被清空。</p><p>在参数和 SQL 完全一样的情况下，我们使用同一个 SqlSession 对象调用同一个 mapper 的方法，往往只执行一次 SQL。因为使用 SqlSession 第一次查询后，MyBatis 会将其放在缓存中，再次查询时，如果没有刷新，并且缓存没有超时的情况下，SqlSession 会取出当前缓存的数据，而不会再次发送 SQL 到数据库。</p><p>由于 SqlSession 是相互隔离的，所以如果你使用不同的 SqlSession 对象，即使调用相同的 Mapper、参数和方法，MyBatis 还是会再次发送 SQL 到数据库执行，返回结果。</p><h3 id="二级缓存">3.3.2. 二级缓存</h3><p>为了解决“不同 SqlSession 对象调用的 Mapper、参数和方法，MyBatis 不会从缓存中获取数据”的问题，我们需要配置二级缓存，使得缓存在SqlSessionFactory 层面上能够提供给各个 SqlSession 对象共享。</p><p>二级缓存是<strong>全局缓存</strong>，作用域超出 session 范围之外，可以被所有 SqlSession 共享。</p><p>一级缓存缓存的是 <strong>SQL 语句</strong>，二级缓存缓存的是<strong>结果对象</strong>。</p><h1 id="Redis">4. Redis</h1><p>Redis是由C语言开发的一款非关系型数据库，其数据存储在内存中，读写速度快，也叫内存数据库，多用于缓存。</p><h2 id="数据类型">4.1. 数据类型</h2><p>string：键值对类型，key(string)-&gt;value(string)。其string是自己写的简单动态字符串（SDS）类型，能保存文本数据和二进制数据，获取字符串长度的时间复杂度为O(1)（C的字符串是O(n)）。<br>应用场景： 一般常用在需要计数的场景。</p><p>list：双向链表。<br>应用场景：发布与订阅或者说消息队列、慢查询。</p><p>hash：类似于HashMap，键值对类型，key(string)-&gt;value(对象)。<br>应用场景：系统中对象数据的存储</p><p>set：类似于HashSet，无序无重复集合。<br>应用场景：存放的数据去重；获取多个集合的交集、并集、差集等。</p><p>sorted set：与set相比，增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。<br>应用场景：需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息。</p><p>bitmap：连续二进制数。1bit可以表示某个元素的值或状态。<br>应用场景： 保存状态信息。比如用户签到情况、活跃用户情况、用户行为统计。</p><h2 id="内存淘汰机制">4.2. 内存淘汰机制</h2><p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最久未使用的数据淘汰</p><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</p><p><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</p><p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最久未使用的 key（这个是最常用的）</p><p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</p><p><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</p><p><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</p><h2 id="持久化">4.3. 持久化</h2><h2 id="缓存问题">4.4. 缓存问题</h2><h3 id="缓存穿透">4.4.1. 缓存穿透</h3><p><strong>缓存穿透</strong>：有大量的请求的key不在缓存中，直接绕过缓存访问了数据库。</p><p>解决方法：<br>1、缓存无效key：如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间；<br>2、布隆过滤器：如果判断不存在则肯定不存在，如果判断存在则可能不存在。</p><h3 id="缓存雪崩">4.4.2. 缓存雪崩</h3><p><strong>缓存雪崩</strong>：突然之间缓存中大量的key失效，然后大量请求直接访问数据库。</p><p>解决方法：<br><strong>Redis服务不可用的情况：</strong><br>1、使用Redis集群<br>2、限流<br><strong>热点缓存失效情况：</strong><br>1、热点缓存随机延长一段失效时间<br>2、热点缓存不设置失效时间，后面手动清理</p><h3 id="缓存击穿">4.4.3. 缓存击穿</h3><p><strong>缓存击穿</strong>：突然之间缓存中某个key失效，访问此key的大量请求直接访问数据库。</p><p>解决方法同缓存雪崩差不多。</p><h1 id="RabbitMQ">5. RabbitMQ</h1><p>RabbitMQ 是一个在分布式系统中存储转发消息的消息中间件。整体模型是生产者消费者模型，负责消息的产生、储存、转发和接收。</p><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/96388546.jpg" class title="图1-RabbitMQ 的整体模型架构"><h2 id="核心组件">5.1. 核心组件</h2><h3 id="Producer和Consumer">5.1.1. Producer和Consumer</h3><p>Producer 生产者：负责生产消息</p><p>Consumer 消费者：负责接收消息</p><h3 id="Exchange">5.1.2. Exchange</h3><p>Exchange 交换器：负责转发消息。收到Producer生成的消息或其他Exchange传递过来的消息，根据路由策略和key匹配将消息转发到Queue中。</p><p>消息头中有RoutingKey（路由键），用来描述该消息的路由规则，需要与交换器的路由策略和BindingKey（绑定键）联合使用。</p><p>交换器的绑定键是与队列进行绑定（映射关系是多对多），当消息的路由键与绑定键匹配，交换器就会将消息转发到对应队列。</p><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/70553134.jpg" class title="Binding(绑定) 示意图"><p><strong>Exchange Types 交换器类型</strong></p><ol><li><strong>direct</strong>（默认）：根据路由键（完全匹配）直接传递消息。把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。常用在处理有优先级的任务。</li><li><strong>fanout</strong>：广播消息。把所有消息广播到与它绑定所有Queue中。</li><li><strong>topic</strong>：与direct类似，根据路由键传递消息，但可以有复杂的匹配规则。</li></ol><ul><li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li><li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li><li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li></ul><ol start="4"><li><strong>headers</strong>（不推荐）：根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。</li></ol><h3 id="Queue">5.1.3. Queue</h3><p>Queue 队列：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费。</p><h3 id="Broker">5.1.4. Broker</h3><p>一个 RabbitMQ Broker 是一个RabbitMQ的服务节点（即一个服务实例）</p><img src="/2022/06/07/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/67952922.jpg" class title="消息队列的运转过程"><h1 id="Docker">6. Docker</h1><h1 id="K8S">7. K8S</h1><h1 id="Eureka-服务注册与发现">8. Eureka 服务注册与发现</h1><h1 id="Ribbon-负载均衡">9. Ribbon 负载均衡</h1><p>主要给服务间调用及API网关转发提供负载均衡的功能</p><h2 id="负载均衡策略">9.1. 负载均衡策略</h2><ul><li>com.netflix.loadbalancer.RandomRule：从提供服务的实例中以随机的方式；</li><li>com.netflix.loadbalancer.RoundRobinRule：以线性轮询的方式，就是维护一个计数器，从提供服务的实例中按顺序选取，第一次选第一个，第二次选第二个，以此类推，到最后一个以后再从头来过；</li><li>com.netflix.loadbalancer.RetryRule：在RoundRobinRule的基础上添加重试机制，即在指定的重试时间内，反复使用线性轮询策略来选择可用实例；</li><li>com.netflix.loadbalancer.WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择；</li><li>com.netflix.loadbalancer.BestAvailableRule：选择并发较小的实例；</li><li>com.netflix.loadbalancer.AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例；</li><li>com.netflix.loadbalancer.ZoneAwareLoadBalancer：采用双重过滤，同时过滤不是同一区域的实例和故障实例，选择并发较小的实例。</li></ul><h1 id="Hystrix-服务容错保护">10. Hystrix 服务容错保护</h1><p>Hystrix具备服务降级、服务熔断、线程隔离、请求缓存、请求合并及服务监控等强大功能。</p><p><code>@EnableCircuitBreaker</code>：开启Hystrix的功能</p><h2 id="服务降级">10.1. 服务降级</h2><p><code>@HystrixCommand(fallbackMethod = &quot;getDefaultUser&quot;)</code>：服务降级</p><ul><li>fallbackMethod：指定服务降级处理方法；</li><li>ignoreExceptions：忽略某些异常，不发生服务降级；</li><li>commandKey：命令名称，用于区分不同的命令；</li><li>groupKey：分组名称，Hystrix会根据不同的分组来统计命令的告警及仪表盘信息；</li><li>threadPoolKey：线程池名称，用于划分线程池。</li></ul><h2 id="请求缓存">10.2. 请求缓存</h2><p>当系统并发量越来越大时，我们需要使用缓存来优化系统，达到减轻并发请求线程数，提供响应速度的效果。</p><ul><li><code>@CacheResult</code>：开启缓存，默认所有参数作为缓存的key，cacheKeyMethod可以通过返回String类型的方法指定key；</li><li><code>@CacheKey</code>：指定缓存的key，可以指定参数或指定参数中的属性值为缓存key，cacheKeyMethod还可以通过返回String类型的方法指定；</li><li><code>@CacheRemove</code>：移除缓存，需要指定commandKey。</li></ul><h2 id="请求合并">10.3. 请求合并</h2><p>微服务系统中的服务间通信，需要通过远程调用来实现，随着调用次数越来越多，占用线程资源也会越来越多。Hystrix中提供了<code>@HystrixCollapser</code>用于合并请求，从而达到减少通信消耗及线程数量的效果。</p><p><code>@HystrixCollapser</code>常用属性：</p><ul><li>batchMethod：用于设置请求合并的方法；</li><li>collapserProperties：请求合并属性，用于控制实例属性，有很多；</li><li>timerDelayInMilliseconds：collapserProperties中的属性，用于控制每隔多少时间合并一次请求；</li></ul><h1 id="OpenFeign-服务调用">11. OpenFeign 服务调用</h1><p>OpenFeign是基于Ribbon和Hystrix的声明式服务调用，整合了上面两个组件的负载均衡和服务容错功能。</p><p>Feign是声明式的服务调用工具，我们只需创建一个接口并用注解的方式来配置它，就可以实现对某个服务接口的调用，简化了直接使用RestTemplate来调用服务接口的开发量。</p><p><code>@EnableFeignClients</code>：开启Feign功能</p><h2 id="服务调用">11.1. 服务调用</h2><p>定义接口，并用注解配置该接口对应的服务名，方法对应的api，然后直接可以远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-service&quot;, fallback = UserFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/create&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/getByUsername&quot;)</span></span><br><span class="line">    <span class="function">CommonResult&lt;User&gt; <span class="title">getByUsername</span><span class="params">(<span class="meta">@RequestParam</span> String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/update&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/delete/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">delete</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务降级-1">11.2. 服务降级</h2><p>开启Hystrix功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#在Feign中开启Hystrix</span></span><br></pre></td></tr></table></figure><p>只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFallbackService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        User defaultUser = <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">&quot;defaultUser&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;User&gt; <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        User defaultUser = <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">&quot;defaultUser&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;User&gt; <span class="title">getByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        User defaultUser = <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">&quot;defaultUser&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(defaultUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="string">&quot;调用失败，服务被降级&quot;</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="string">&quot;调用失败，服务被降级&quot;</span>,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Gateway-服务网关">12. Gateway 服务网关</h1><p>Spring Cloud Gateway 为 SpringBoot 应用提供了API网关支持，具有强大的智能路由与过滤器功能，它有以下特性：</p><ul><li>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；</li><li>动态路由：能够匹配任何请求属性；</li><li>可以对路由指定 Predicate（断言）和 Filter（过滤器）；</li><li>集成Hystrix的断路器功能；</li><li>集成 Spring Cloud 服务发现功能；</li><li>易于编写的 Predicate（断言）和 Filter（过滤器）；</li><li>请求限流功能；</li><li>支持路径重写。</li></ul><h2 id="相关概念">12.1. 相关概念</h2><ul><li>Route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；</li><li>Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；</li><li>Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。</li></ul><h2 id="Predicate-路由匹配规则">12.2. Predicate 路由匹配规则</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">$&#123;service-url.user-service&#125;</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">//</span> <span class="string">在指定时间之后的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">After=2019-09-24T16:30:00+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="string">//</span> <span class="string">在指定时间之前的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Before=2019-09-24T16:30:00+08:00[Asia/Shanghai]</span></span><br><span class="line">            <span class="string">//</span> <span class="string">在指定时间区间内的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Between=2019-09-24T16:30:00+08:00[Asia/Shanghai],</span> <span class="number">2019-09-25T16:30:00+08:00</span>[<span class="string">Asia/Shanghai</span>]</span><br><span class="line">            <span class="string">//</span> <span class="string">带有指定Cookie的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=username,macro</span></span><br><span class="line">            <span class="string">//</span> <span class="string">带有指定请求头的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br><span class="line">            <span class="string">//</span> <span class="string">发送指定方法的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span></span><br><span class="line">            <span class="string">//</span> <span class="string">发送指定路径的请求会匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/&#123;id&#125;</span></span><br><span class="line">            <span class="string">//</span> <span class="string">带指定查询参数的请求可以匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=username</span></span><br><span class="line">            <span class="string">//</span> <span class="string">从指定远程地址发起的请求可以匹配该路由。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.1.1/24</span></span><br><span class="line">        <span class="string">//</span> <span class="string">使用权重来路由相应请求，以下表示有80%的请求会被路由到localhost:8201，20%会被路由到localhost:8202。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8201</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://localhost:8202</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="Route-Filter-路由过滤器">12.3. Route Filter 路由过滤器</h2><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_parameter_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8201</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user-service/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">          <span class="string">//</span> <span class="string">给请求添加参数的过滤器。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=username,</span> <span class="string">macro</span></span><br><span class="line">            <span class="string">//</span> <span class="string">对指定数量的路径前缀进行去除的过滤器。</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=2</span></span><br><span class="line">            <span class="string">//</span> <span class="string">在原来路径上增加前缀</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrefixPath=/user</span></span><br><span class="line">            <span class="string">//</span> <span class="string">Hystrix服务熔断过滤器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hystrix</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">fallbackcmd</span></span><br><span class="line">                <span class="attr">fallbackUri:</span> <span class="string">forward:/fallback</span></span><br></pre></td></tr></table></figure><h2 id="动态路由">12.4. 动态路由</h2><p>默认情况下会根据注册中心注册的服务列表，以服务名为路径创建动态路由</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9201</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启从注册中心动态创建路由的功能</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment">#使用小写服务名，默认是大写</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.springframework.cloud.gateway:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringMVC、SpringBoot、MyBatis、Redis、RabbitMQ等框架介绍</summary>
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="后端框架" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>2022面试题总结</title>
    <link href="http://example.com/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-07T10:40:00.000Z</published>
    <updated>2022-11-22T07:57:42.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022面试题总结">1. 2022面试题总结</h1><h2 id="阿里密码算法岗">1.1. 阿里密码算法岗</h2><p>1、讲一讲你的项目</p><p>2、你做的优化与其他人有什么优势？</p><p>3、了解椭圆曲线和全同态吗？</p><p>4、描述一下NTT和你们的T-NTT</p><p>5、KEM如何转换成AKE</p><h2 id="阿里云智能-ProtalDB">1.2. 阿里云智能-ProtalDB</h2><p>1、需求模糊，先考虑需求</p><p>2、编程：外观数列</p><p>3、Http和Https区别、Https通讯过程、传递什么数据</p><p>Http：超文本传输协议，是无状态的，属于应用层协议，默认端口为80，以TCP的方式建立连接，传输的数据都是未经过加密的明文，容易受黑客监听和拦截</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/v2-e367a5e3bc28fb7fd083ddc201e7e693_720w.png" class title="img"><p>Http通讯过程：<br>(1).客户端请求连接，进行TCP三次握手后建立连接<br>(2).传输数据（明文传输）<br>(3).客户端请求释放连接，TPC四次挥手后释放连接</p><p>Https：Https &#x3D; Http + SSL&#x2F;TLS，是安全的超文本传输协议，默认端口为443，TLS是传输层安全协议</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/v2-5e2241fae8b593ff7f3b3a308ef81c10_720w.png" class title="img"><p>证书派发和验证过程：<br>证书颁发机构（CA，Certificate Authority），客户端和服务端都信任CA<br>(1).CA知道服务端的公钥，它先对这个公钥hash生成摘要，再使用自己的私钥对此摘要签名，并将签名附在证书中派发给服务端<br>(2).服务端保存证书，等待客户端请求，发送自己的公钥和证书给客户端<br>(3).客户端收到服务端的公钥和证书，客户端通过证书中的信息，找到对应CA，使用CA的公钥对证书中的签名验证得到摘要a，再对服务端的公钥进行hash得到摘要b，将摘要a和摘要b对比，若相等则表示身份正确。</p><p>Https通讯过程：<br>(1).客户端请求连接，进行TCP三次握手后建立连接<br>(2).服务器把证书发送给客户端（证书是第三方机构派发给服务器的，其中有服务器公钥的签名等信息）<br>(3).客户端对证书进行验证，如果验证失败，则表示服务器不可信<br>(4).客户端从证书中取出服务器公钥，并使用这个公钥对自己的对称加密算法和对称密钥进行加密，发送给服务器<br>(5).服务器使用自己的私钥解密，得到对称加密算法和对称密钥<br>(6).双方使用相同的对称加密算法和对称密钥，对数据加密处理后再传输<br>(7).客户端请求释放连接，TPC四次挥手后释放连接</p><p>4、没有证书会导致什么漏洞</p><p>没有证书，客户端拿到公钥，但不能确定这个公钥是谁的，可能是攻击者用自己的公钥替换了服务端的公钥</p><p>5、MySQL隔离级别，每个隔离级别详细说明</p><p>读未提交：事务可以读到未提交的更新。</p><p>读已提交：事务可以读到已提交的更新。</p><p>可重复读：无论其他事务是否有更新操作，本事务多次读取的数据是相同的，除非自己更新。</p><p>串行化：事务之间是串行的，互不影响。</p><p>6、MySQL的FIND_IN_SET()函数</p><p>FIND_IN_SET(str, strList);</p><ul><li>str：要查找的字符串</li><li>strList：从中搜索的以逗号分割的字符串列表</li></ul><h2 id="字节Tiktok-一面-3-x2F-24">1.3. 字节Tiktok 一面 3&#x2F;24</h2><p>1、项目用到的框架</p><p>2、Mysql语句，按时间顺序查找</p><p><code>SELECT userID, SUM(totalWeight) as weight_sum FROM order_recycle WHERE state = &#39;1&#39; GROUP BY userID HAVING weight_sum &gt;= 1000 ORDER BY orderDate</code></p><p>3、having 和 where 的区别</p><p>where 是分组前的条件筛选，having 是对 where 和 group by 分组后的数据再一次筛选5</p><p>4、执行Mysql语句时顺序是怎么样的</p><p><strong>书写顺序：</strong><br>select -&gt; distinct -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; order by -&gt; limit<br>必须字段：select、from</p><p><strong>执行顺序：</strong><br>from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; sum、count、max、avg -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit</p><p><strong>FORM</strong>: 对FROM的左表和右表计算笛卡尔积。产生虚表VT1</p><p><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。</p><p><strong>JOIN</strong>： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果 from 子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</p><p><strong>WHERE</strong>： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。</p><p><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</p><p><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6</p><p><strong>HAVING</strong>： 对虚拟表VT6，即已经分组的数据进行过滤的条件，只有符合的记录才会被 插入到虚拟表VT7中</p><p><strong>SELECT</strong>： 执行select操作，选择指定的列，插入到虚拟表VT8中</p><p><strong>DISTINCT</strong>： 对VT8中的记录进行去重。产生虚拟表VT9</p><p><strong>ORDER BY</strong>: 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10</p><p><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</p><p>5、怎么建索引</p><p>对 <code>ON</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>ORDER BY</code>的字段建立索引</p><p>6、Mysql索引的数据结构</p><p>7、线程安全的单例模式，为什么单例对象要用 <code>volatile</code>修饰？</p><p><strong>双重校验</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例成员变量</span></span><br><span class="line">    <span class="comment">// volatile 防止JVM的指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new实例不是原子操作，实例初始化分三个步骤：<br>（1）分配内存空间<br>（2）初始化实例<br>（3）实例指向这个内存空间（此时才不为null）</p><p>如果没有 <code>volatile</code>修饰，线程A来到18行，正在对实例进行初始化，但是初始化顺序为(1)-&gt;(3)-&gt;(2)，当线程A完成(1)-&gt;(3)步骤时，线程B进入，判断实例不为null，然后返回实例，但这个实例是没有初始化的（线程A还没完成步骤(2)），如果使用则会报错。所以使用 <code>volatile</code>是为了防止指令重排。</p><p>单例模式的几种实现，以及各种实现的特点：</p><table><thead><tr><th align="left">单例模式的实现</th><th>线程安全</th><th>并发性能好</th><th>延迟加载</th><th>序列化&#x2F;反序列化</th><th>能抵御反射攻击</th></tr></thead><tbody><tr><td align="left">饿汉式</td><td>Y</td><td>Y</td><td></td><td></td><td></td></tr><tr><td align="left">懒汉式</td><td></td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td align="left">懒汉式（加锁）</td><td>Y</td><td></td><td>Y</td><td></td><td></td></tr><tr><td align="left">DCL（双重校验）</td><td>Y</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td align="left">静态内部类</td><td>Y</td><td>Y</td><td>Y</td><td></td><td></td></tr><tr><td align="left">枚举</td><td>Y</td><td>Y</td><td></td><td>Y</td><td>Y</td></tr></tbody></table><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态内部类，类加载时不会初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、编程：最大正方形面积</p><p>动态规划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] // 存储以[i,j]为右下角的最大正方形边长</span><br><span class="line">dp[i][j] = MIN&#123;dp[i-1][j-1], dp[i-1][j], dp[i][j-1]&#125; + 1, nums[i][j] == 1</span><br></pre></td></tr></table></figure><h2 id="蚂蚁-支付宝-一面-3-x2F-29">1.4. 蚂蚁 支付宝 一面 3&#x2F;29</h2><p>1、项目，如何定时生成长期订单，如果生成的过程中出现异常怎么办</p><p>2、密码是明文吗？MD5加密</p><p>3、加密和签密的区别，对称加密和非对称加密，有什么了解的算法</p><p>4、并发访问时如何处理</p><p>5、乐观锁和悲观锁了解吗（说了一下CAS乐观锁的实现）</p><p>6、MySQL事务特性（脑抽忘了两个）</p><p>原子性：要么做要么不做</p><p>持久性：事务对数据库的影响是持久的</p><p>独立性：不同事务之间不会相互影响</p><p>一致性：数据的变化符合逻辑，符合“能量守恒定律”</p><p>7、索引用来做什么，什么时候要用到索引，每个列都设置索引的话搜索速度是不是最快的？</p><p>8、了解什么设计模式，单例模式实现</p><p>9、volatile功能</p><p>10、算法题：两个队列模拟一个栈</p><p>反问：</p><p>1、工作地点在上海，线上办公</p><p>2、主要做什么工作？</p><p>支付宝的支付业务，商家码，二维码支付那些</p><h2 id="字节-一面-3-x2F-31">1.5. 字节 一面 3&#x2F;31</h2><p>1、讲一下项目</p><p>2、项目用了Redis，用来做什么？Redis和MySQL有什么区别？</p><p>3、Redis和MySQL如何保证数据一致？</p><p>读操作不会导致两者数据不一致：若读命中Redis缓存，则直接返回Redis中的数据；若没有命中，则从MySQL数据库中查询数据，并且放入缓存中，再返回查询的数据。读操作是可以保证数据一致的，他没有修改数据。</p><p>写操作会导致两者数据不一致。写操作要更新缓存和数据库的内容，这引出两个问题：执行顺序问题和更新缓存的策略问题。</p><p>更新缓存的策略：<br>（1）直接更新缓存：不会造成缓存失效，但如果要更新的数据较复杂，更新的开销较大，多线程更新时会导致与数据库数据不一致的情况（需要串行化执行来解决）<br>（2）直接淘汰缓存（推荐）：简单易操作，但会导致一次缓存失效</p><p>执行顺序：（1）先淘汰缓存，在更新数据库；（2）先更新数据库，再淘汰缓存（这个方法更好）</p><p>两个顺序都会导致问题，如果出现错误，都需要<strong>重试机制</strong>，保证执行完成</p><blockquote><p><a href="https://developer.aliyun.com/article/712285">如何保证缓存(redis)与数据库(MySQL)的一致性</a></p></blockquote><p>4、@Transaction是怎么实现事务的？</p><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li><code>PlatformTransactionManager</code>： （平台）事务管理器，Spring 事务策略的核心。</li><li><code>TransactionDefinition</code>： 事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）。</li><li><code>TransactionStatus</code>： 事务运行状态（是否是新事务，是否有恢复点，是否只回滚，是否已完成）。</li></ul><p>7种事务传播行为：</p><ul><li><code>Propagation.REQUIRED</code>（默认）：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务<ul><li>如果外部方法没有开启事务的话，<code>REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被 <code>REQUIRED</code>的话，所有 <code>REQUIRED</code>修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</li></ul></li><li><code>Propagation.REQUIRES_NEW</code>：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><code>Propagation.NESTED</code>：如果当前存在事务，就在<strong>嵌套</strong>事务内执行；如果当前没有事务，则创建一个新的事务。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常（mandatory，强制性）。</li></ul><p>以下事务传播行为不会回滚：</p><ul><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><code>Propagation.NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><blockquote><p><a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">Spring事务总结</a></p></blockquote><p>5、如果没有@Transaction注解，你自己怎么实现多并发安全？</p><p>业务代码上，使用 <code>synchronized</code>或 <code>ReentrantLock</code>等锁机制，保证多线程下的并发安全</p><p>数据库层面上，SQL语句使用事务实现操作的原子性。</p><p>6、操作系统中，fork是什么，怎么实现的？</p><p>fork 分叉，作用是克隆进程。父进程和克隆出来的子进程几乎没有区别，可以执行相同的操作，也可以根据传入的参数执行不同操作。</p><p>fork() 有三种返回值：<br>（1）在父进程中，返回新创建的子进程的pid<br>（2）在子进程中，返回0<br>（3）出现错误，返回-1</p><p>fork实现有两步：<br>（1）复制进程资源：进程pcb，程序体（代码段、数据段等），用户栈，内核栈，虚拟内存池，页表<br>（2）执行进程：将进程加入就绪队列，等待cpu调度</p><p>7、虚拟内存如何实现？页面置换算法有哪些？</p><p>8、HTTP和HTTPS的区别</p><p>9、HTTPS如何抵挡中间人攻击？</p><p>10、分布式锁了解吗，如何实现？</p><p>线程锁：同一进程，多个线程并发访问共享资源，使用 <code>synchronized</code>或 <code>ReentrantLock</code>等线程锁进行互斥控制，同一时刻仅有一个线程执行该方法或该代码段。</p><p>进程锁：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过 <code>synchronized</code>等线程锁实现进程锁。可以使用本地系统的信号量机制来控制。</p><p>分布式锁：当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</p><p>分布式锁的三种实现方式：</p><p>（1）数据库乐观锁：需要一个数据库，创建一个分布式锁表，加锁就增加一条记录，释放锁就将记录删除。</p><p>乐观锁的实现：乐观锁一般通过 version 来实现，也就是在数据库表创建一个 version 字段，每次更新成功，则 version+1，读取数据时，我们将 version 字段一并读出，每次更新时将会对版本号进行比较，如果一致则执行此操作，否则更新失败！</p><p>悲观锁的实现：利用数据库 <code>select ... for update</code>当前读语句，如果读结果为null则表示当前没有锁，则可以进去加锁；否则，不断循环重试。</p><p>（2）基于ZooKeeper的分布式锁：ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><ol><li>建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent）</li><li>每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（<code>EPHEMERAL_SEQUENTIAL</code>），通过组成特定的名字 name+lock+顺序号。</li><li>在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。</li><li>假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件。同时在这里阻塞。等待监听事件的发生，获得锁控制权。</li><li>当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。</li></ol><p>（3）基于Redis的分布式锁：需要一个Redis服务器来保存互斥的锁</p><p>【1】利用 SETNX 和 SETEX</p><ul><li>SETNX(SET If Not Exists)：当且仅当 Key 不存在时，则可以设置，否则不做任何动作。</li><li>SETEX：可以设置超时时间</li></ul><p>SETNX成功后 -&gt; 用SETEX设置超时时间 -&gt; 执行任务 -&gt; DELETE解锁</p><p>SETNX失败 -&gt; 不断重试SETNX</p><p>问题：SETNX和SETEX不是原子操作，如果在SETEX执行失败，没能设置超时时间，那么这个锁将无法释放</p><p>解决：使用Lua脚本，将SETNX和SETEX写到一起</p><p>【2】使用Redisson实现</p><p>加锁Lua脚本</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3czNzI0MjYwOTY=,size_16,color_FFFFFF,t_70.png" class title="img"><p>解锁Lua脚本</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/format,png.png" class title="img"><p>11、编程题</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1647389426-lcjtXu-%E7%BD%91%E9%A1%B5%E6%8D%95%E8%8E%B7_16-3-2022_8728_codetop.cc.jpeg" class title="网页捕获_16-3-2022_8728_codetop.cc.jpeg"><p>反问：</p><p>1、部门是大力教育</p><h2 id="字节-二面-4-x2F-2">1.6. 字节 二面 4&#x2F;2</h2><p>1、输入url到返回到客户端渲染页面，整个请求的过程说一下</p><ol><li>url域名-&gt;DNS解析-&gt;IP地址</li><li>请求建立TCP连接（三次握手）</li><li>客户端向该IP地址发送HTTP请求</li><li>HTTP报文封装成TCP&#x2F;IP报文在路由器之间传递，路由器使用OSPF（Open Shortest Path First，开放最短路径优先协议）进行寻路</li><li>当报文传递到目标服务器所在局域网的路由器后，路由器能直接查询到该IP地址，并用ARP（Address Resolution Protocol，地址解析协议）解析IP地址，得到机器的MAC地址</li><li>交换机通过MAC地址来转发数据帧</li><li>服务器接收到该帧，解封装成HTTP请求，然后再执行MVC的操作处理请求，返回HTTP响应</li><li>HTTP响应经过相同流程传送回客户端，客户端浏览器渲染页面</li><li>断开TCP连接</li></ol><p>2、MySQL事务特性（一致性到底是什么？没解释清楚）</p><p>一致性，执行事务前后，数据应保证业务逻辑和客观显示上的一致</p><p>3、一个事务中能否修改多个数据库的表？为什么不能？（母鸡）</p><p>不能，因为一个事务只能对应一个数据库，如果要处理多个数据库，应该开启多个事务。</p><p>4、多个线程更新多张表，能否放到一个事务中执行，为什么不能？（母鸡）</p><p>如果开启一个事务，事务中更新同一个数据库的多张表，这是可以的</p><p>多线程的情况下，每个线程都更新一张表，是不能整合到同一事务中的，他们必须各自开启事务</p><p>5、执行exe文件到输出’hello’的过程（操作系统，系统调用）</p><p>操作系统将exe二进制文件从外存拉入内存，CPU从内存中获取该文件的机器代码，将要输出的字节流’hello’存放到寄存器中，执行print的指令，进行系统调用，程序从用户态变成内核态，在内核态中系统调用输出设备，把’hello’字节流传入输出设备，输出设备再传递到显示设备，执行完毕后返回程序，程序继续执行后面的步骤。</p><p>6、单例模式实现</p><p>7、排序算法，以及各个时间复杂度，哪些是稳定的？</p><table><thead><tr><th>排序算法</th><th>时间复杂度（最好，平均，最坏）</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>直接插入排序</td><td>$O(n), O(n^2), O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>冒泡排序</td><td>$O(n), O(n^2), O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>简单选择排序</td><td>$O(n^2), O(n^2), O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>希尔排序</td><td></td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>快速排序</td><td>$O(nlogn), O(nlogn), O(n^2)$</td><td>$O(log_{2}n)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(nlogn), O(nlogn), O(nlogn)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>2路归并排序</td><td>$O(nlogn), O(nlogn), O(nlogn)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(d(n+r)), O(d(n+r)), O(d(n+r))$, <br>d是位数, n是排序数组长度, r是基数</td><td>$O(r)$</td><td>稳定</td></tr></tbody></table><p>8、编程题：LFU（焯！）</p><h2 id="字节-三面-4-x2F-6">1.7. 字节 三面 4&#x2F;6</h2><p>1、拿手的项目，项目技术上的难点</p><p>2、谈谈你的研究方向，对你的影响，对未来职业的影响</p><p>3、考了前两面答的不好的题目：事务一致性，HTTPS，执行exe的过程</p><p>4、SSL证书是怎么申请的，CA再派发证书时，他们的分布式如何负载均衡？</p><p>5、实习时长？</p><p>6、使用过什么数据库，MySQL默认隔离级别是什么？</p><p>7、MySQL的MVCC了解吗？</p><p>8、编程题1：队列实现栈</p><p>9、编程题2：求平方根</p><h2 id="蚂蚁-二面-4-x2F-6">1.8. 蚂蚁 二面 4&#x2F;6</h2><p>1、操作系统，BIO，NIO，AIO，他们的使用场景是什么？</p><p>BIO 同步阻塞，服务器实现模式一个连接一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情，就会造成不必要的线程开销。适用于连接数目比较小且固定的结构。</p><p>NIO 同步非阻塞，服务器实现模式一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求时才启动一个线程处理。用户进程也需要时不时地询问IO操作是否就绪，这就要求用户进程不停的去询问。适用于连接数目多且连接比较短的架构，比如聊天服务器。</p><p>NIO 异步阻塞，应用发起一个 IO 操作以后，不需要等待内核 IO 操作完成，等待内核完成 IO 操作以后会通知应用程序，通过 select 系统调用来完成的，而 select 函数本身的实现方式就是阻塞的。</p><p>AIO 异步非阻塞，用户进程只需要发起一个IO操作便立即返回，等 IO 操作真正完成以后，应用程序会得到IO操作完成的通知。适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器。</p><blockquote><p><a href="https://developer.aliyun.com/article/726698">JAVA中BIO、NIO、AIO的分析理解</a></p><p><a href="https://javaguide.cn/java/io/io-model.html#aio-asynchronous-i-o">JAVA的IO模型</a></p></blockquote><p>2、Socket网络编程</p><p>3、MySQL事务的实现</p><p>MVCC 多版本控制</p><p>4、项目中为什么不用多线程处理请求</p><p>5、什么是线程安全，如何保证线程安全</p><p>6、sychronized和ReentrantLock的区别，ReentrantLock如何唤醒线程</p><p>sychronized和ReentrantLock都是悲观锁，一个线程获得锁之后，其他线程会阻塞</p><p>7、线程池的结构</p><p>ThreadPoolExecutor构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="params"><span class="function">    TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="params"><span class="function">    BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="params"><span class="function">    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="params"><span class="function">    RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>execute方法流程</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-16595253339731.png" class title="图解线程池实现原理"><p>8、单机项目如何提高并发（应该要回答多线程）</p><p>9、项目中用过什么设计模式</p><p>10、最近在学什么技术</p><h2 id="美团-一面-4-x2F-12">1.9. 美团 一面 4&#x2F;12</h2><p>1、进程和线程的区别</p><p>2、内存管理方法</p><p>3、HashMap的key能否为null？</p><table><thead><tr><th></th><th>Key能否为null</th><th>Value能否为null</th></tr></thead><tbody><tr><td>HashTable</td><td>N</td><td>N</td></tr><tr><td>ConcurrentHashMap</td><td>N</td><td>N</td></tr><tr><td>TreeMap</td><td>N</td><td>Y</td></tr><tr><td>HashMap</td><td>Y</td><td>Y</td></tr></tbody></table><p>4、HashMap数据结构，如何解决冲突，如何获取哈希值</p><p>5、除了链表法解决冲突，还有什么方法</p><p>线性探测法</p><p>6、JDK中有哪个类使用了线性探测法解决冲突</p><p>ThreadLocalMap</p><p>7、TCP三次握手，为什么不能两次</p><p>8、Linux命令，查看进程，查看内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></span><br><span class="line">ps -aux</span><br><span class="line">  -a 显示所有进程</span><br><span class="line">  -u 用户以及其他详细信息</span><br><span class="line">  -x 显示没有控制终端的进制</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 动态监视进程活动与系统负载</span></span><br><span class="line">top</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看内存</span></span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><p>9、sychronized如何实现？</p><p>依赖于JVM的相关指令</p><p>（1）修饰代码块：</p><ul><li>使用 <code>monitorenter</code>指令获取锁，判断锁的计数器是否为0，为0时，可以尝试获取锁，若不为0，则阻塞（获取对象锁失败则阻塞）。</li><li>使用 <code>monitorexit</code>释放锁，判断本线程是否是锁的拥有者线程，若是，则将锁的计数器减1，直到为0时完全释放锁，若不是，则结束。</li></ul><p>（2）修饰方法：用 <code>ACC_SYNCHRONIZED</code>标识，表示该方法是同步的方法，JVM执行该方法时用同步调用。如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><p>10、sychronized上锁过程</p><ul><li>每个锁有一个计数器，当计数器为0时，表示没有线程使用这个锁，此时本线程可以上锁，把计数器改为1</li><li>同一线程再次上锁，计数器会加1</li><li>同一线程释放一次锁，计数器减1，直到为0完全释放该锁</li><li>其他线程上锁时，如果看到计数器不为0，则会阻塞；当计数器为0时，他们争抢式上锁</li></ul><p>11、CAS操作</p><p>12、Redis数据结构有哪些？</p><p>13、Redis分布式锁如何实现？</p><p>14、Redis过期的key如何处理？</p><p>懒惰方式：每次查询的时候才检查是否过期</p><p>定时方式：每隔一段时间删除过期key</p><p>15、线程池</p><p>16、根据什么配置线程池的线程数量？</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p>17、线程池工作过程</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" class title="图解线程池实现原理"><p>18、ThreadLocal实现原理</p><p><a href="https://javaguide.cn/java/concurrent/threadlocal.html#threadlocal%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">ThreadLocal详解</a></p><p>19、SpringBoot的AutoConfig如何实现？SPI了解吗？</p><p><strong>自动装配</strong>：用户只需要引入对应jar包，Spring会扫描对应的 <code>spring.factories</code>文件，自动加载里面的模块。</p><p><code>@SpringBootApplication</code>中包括三个关键注解 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code></p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li><li><code>@ComponentScan</code>： 扫描被 <code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类，可以自定义不扫描某些 bean。</li></ul><p><code>@EnableAutoConfiguration</code>通过 <code>AutoConfigurationImportSelector</code>类来实现自动装配功能，<code>AutoConfigurationImportSelector</code>实现了 <code>ImportSelector</code>接口的 <code>selectImports</code>方法，该方法的功能是<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>（根据 <code>ConditionOnXXX</code>条件，调用 <code>SpringFactoriesLoader </code>类，加载 <code>META-INF/spring.factories</code>的配置类到IoC容器中）</p><p><strong>SPI</strong>：Service Provider Interface，一种<strong>服务提供发现机制</strong>，运用了面向接口编程的思想，作用是为被扩展的API寻找服务实现。</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/1620.png" class title="img"><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的 <code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><p>20、SpringBoot的注入是byType还是byName？</p><p>byType：根据<strong>变量类型</strong>注入，当有多个实现类，则会报错</p><p>byName：根据<strong>变量名</strong>注入</p><p><code>@Autowired</code>先通过byType方式注入，若检测到有多个实现类，则根据变量名byName注入（如变量名为numberServiceImp，它默认查找NumberServiceImp类），若找不到与变量名相同的实现类则报错。也可以用 <code>@Qulifier(&quot;xxx&quot;)</code>指定特定实现类注入（里面的名字要与 <code>@Service(&quot;xxx&quot;)</code>相同）。</p><p>21、&#x3D;&#x3D;与equals的区别</p><p>22、协程了解吗？</p><p>协程（Coroutines）是一种比线程更加轻量级的存在。协程完全由程序所控制（在用户态执行），带来的好处是性能大幅度的提升。一个线程可以有多个协程。协程是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处继续运行。</p><p><strong>一个线程内的多个协程的运行是串行的</strong>，这点和多进程（多线程）在多核CPU上执行时是不同的。 多进程（多线程）在多核CPU上是可以并行的。<strong>当线程内的某一个协程运行时，其它协程必须挂起。</strong></p><p>优点：协程切换在线程内完成，无需系统内核的上下文切换，开销小；无需原子操作锁定及同步的开销，不用担心资源共享的问题；单核 CPU 即便支持上万的协程</p><p>缺点：无法使用CPU的多核；在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。</p><p>协程的使用：</p><ul><li>计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</li><li>IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程（不等待任务结束就可以去执行其他代码）。</li></ul><p>23、编程：判断有向图中是否存在环</p><h2 id="美团-二面-4-x2F-15">1.10. 美团 二面 4&#x2F;15</h2><p>1、未来职业规划</p><p>2、编程：非递归中序遍历</p><p>3、编程：n个数中有1个唯一的数，其他数都出现2次</p><p>4、编程：n个数中有1个唯一的数，其他数都出现3次</p><p>5、编程：n个数中有2个不相同的数，其他数都出现2次，求这2个数</p><p>6、编程：n个螺母，n个螺帽，都是乱序，只能比较螺母和螺帽，求匹配的螺母和螺帽（快排思想）</p><h2 id="南方基金-一面-7-x2F-28">1.11. 南方基金 一面 7&#x2F;28</h2><p>1、10w个长度为10的不相同的字符串，添加一个新的字符串，如何判重？</p><p>可以用一个Set集合存所有字符串</p><p>2、如果用Set存放这10w个字符串，存储空间如何计算？</p><p>3、100亿个不定长的不相同的字符串，添加一个新的字符串，如何判重？</p><p>布隆过滤器</p><h2 id="字节互娱-一面-8-x2F-5">1.12. 字节互娱 一面 8&#x2F;5</h2><p>1、项目使用的框架如何选型，学习新技术的过程</p><p>2、项目需求开发过程</p><p>3、项目遇到困难怎么解决</p><p>4、分析型数据库？</p><p><strong>OLAP</strong>（On-Line Analytical Processing）：联机分析处理，OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的<strong>动态报表系统</strong>。</p><p>OLTP（on-line transaction processing）：联机事务处理，传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，记录即时的增、删、改、查。</p><table><thead><tr><th>不同点</th><th>OLTP</th><th>OLAP</th></tr></thead><tbody><tr><td>用户</td><td>操作人员，底层管理人员</td><td>决策人员，高级管理人员</td></tr><tr><td>功能</td><td>日常操作处理</td><td>分析决策</td></tr><tr><td>DB设计</td><td>面向应用</td><td>面向主题</td></tr><tr><td>数据</td><td>当前，最新，细节，二维，分立，100MB-GB</td><td>历史，聚集，多维，集成，统一，100GB-TB</td></tr><tr><td>存取</td><td>读&#x2F;写数十条数据</td><td>读百万条数据</td></tr><tr><td>工作单位</td><td>简单的事务</td><td>复杂的查询</td></tr><tr><td>用户数</td><td>上千</td><td>上百万</td></tr><tr><td>时间要求</td><td>实时性</td><td>对时间要求不严格</td></tr><tr><td>主要应用</td><td>数据库</td><td>数据仓库</td></tr></tbody></table><p>6、HTTP和RPC的区别</p><p><strong>HTTP</strong>：超文本传输协议，请求-响应协议，基于TCP，规定了客户端和服务端之间的通信格式</p><p>请求报文格式：请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体</p><p>响应报文格式：状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体</p><p>缺点：主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p><p><strong>RPC</strong>：远程过程调用（与之相对的是本地调用），即调用的方法不是本地实现的方法，是其他微服务实现的方法，但是使用方式却像本地调用一样简单。RPC通信可以使用HTTP协议，也可以TCP协议，也可以是自定义的协议。</p><p>相较于HTTP，PRC封装了服务发现、负载均衡、熔断降级等面向服务的高级特性。当使用自定义协议通信时，效率上也会更快。</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/webp.webp" class title="img"><p>PRC调用过程，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/980882-20200610112526160-1034412392.png" class title="img"><p>7、TCP和UDP区别？TCP有什么优势？</p><p>8、进程与线程的区别，进程的通信方式，线程的通信方式</p><table><thead><tr><th></th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>调度</td><td></td><td>CPU调度的基本单位</td></tr><tr><td>资源</td><td>拥有资源的基本单位</td><td>本身含少量资源，共享同一进程的资源</td></tr><tr><td>开销</td><td>进程切换开销较大</td><td>线程切换开销较小</td></tr><tr><td>通信</td><td>共享存储，消息传递，管道通信</td><td>volatile，wait&#x2F;notify，join，管道输入&#x2F;输出</td></tr></tbody></table><p>9、线程状态，什么情况会阻塞？</p><p>10、Spring理解，IOC，AOP</p><p>11、Spring的设计模式有哪些？</p><p>（1）<strong>工厂模式</strong></p><p><code>BeanFactory</code>：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</p><p><code>ApplicationContext</code>：容器启动的时候，一次性创建所有 bean 。扩展了<code>BeanFactory</code>的功能，有其他额外功能。</p><ul><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的 XML 文件载入上下文定义信息。</li></ul><p>（2）<strong>单例模式</strong>：Spring 中 bean 的默认作用域就是 singleton(单例)</p><p>（3）<strong>代理模式</strong>：Spring AOP（面向切面编程），两种实现方式，JDK Proxy和CGLib Proxy</p><p>（4）<strong>模板模式</strong>：使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><p>Spring中的<code>jdbcTemplate</code>和<code>hibernateTemplate</code>等以 Template 结尾的对数据库操作的类都用到了模板模式。</p><p>（5）<strong>观察者模式</strong>：表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。</p><p>Spring 事件驱动模型</p><p>（6）<strong>适配器模式</strong>：将一个接口转换成客户希望的另一个接口，通过适配器可以兼容接口不同的类</p><p>Spring AOP 的增强或通知(Advice) <code>AdvisorAdapter</code> </p><p>Spring MVC 中的<code>HandlerAdapter</code></p><p>（7）<strong>装饰者模式</strong>：动态地给对象添加一些额外的属性或行为</p><p><code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p><p>12、反向代理</p><p>直接访问：用户直接与web服务器交互，没有经过代理服务器</p><p>​路径：用户浏览器&lt;–&gt;web服务器</p><p>正向代理：用户通过一个代理服务器（可以理解为一个请求中转站）与web服务器交互，用户需要主动配置代理服务器地址</p><p>​路径：【用户浏览器&lt;–&gt;正向代理服务器】&lt;–&gt;web服务器</p><p>​作用：隐藏用户信息，直接访问失效时可以通过代理来访问，安全审查（可以监管用户的浏览信息）</p><p>反向代理：负责转发用户的请求到对应web服务器，是web服务器的代理，用户把反向代理服务器当作web服务器</p><p>​路径：用户浏览器&lt;–&gt;【反向代理服务器&lt;–&gt;web服务器】</p><p>​作用：隐藏服务器信息，负载均衡（用合适的方法分配请求给不同进程或服务器，减少单个进程或服务器的压力），缓存，</p><p>13、Mysql事务，四大特性ACID</p><p>14、事务传播，什么时候会用到？</p><p>嵌套事务的时候，事务之间会有事务传播</p><p>15、Mysql如何使用命中索引加快查询，为什么索引可以加快order by排序？</p><p>16、使用过explain查看select语句是否命中索引吗？</p><p>explain，提供有关 MySQL 如何执行语句的信息</p><p>explain + select&#x2F;delete&#x2F;insert&#x2F;update&#x2F;replace语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">explain select * from order_recycle;</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table         | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | order_recycle | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 6426 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+---------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">explain SELECT 1, 2 UNION SELECT &#x27;a&#x27;, &#x27;b&#x27;;</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | NULL       | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used  |</span><br><span class="line">|  2 | UNION        | NULL       | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used  |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">列名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id">id</a></td><td align="left">序号</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type">select_type</a></td><td align="left">查询类型</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table">table</a></td><td align="left">查询的表名</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions">partitions</a></td><td align="left">匹配的分区（查询基于分区表，显示查询将访问的分区）</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type">type</a></td><td align="left">关联类型，显示表如何连接</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys">possible_keys</a></td><td align="left">可能选择的索引</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key">key</a></td><td align="left">实际选择的索引</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len">key_len</a></td><td align="left">选择的索引的长度（字节）</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref">ref</a></td><td align="left">用来与索引比较的列或常量（const，func表示使用的是函数的结果，NULL，字段名）</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows">rows</a></td><td align="left">估计要查询的行数</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered">filtered</a></td><td align="left">根据表条件过滤的行数百分比</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra">Extra</a></td><td align="left">额外信息</td></tr></tbody></table><p><strong>select_type</strong></p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">SIMPLE</td><td align="left">简单SELECT（没有使用UNION或subqueries子查询）</td></tr><tr><td align="left">PRIMARY</td><td align="left">最外层的SELECT</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/union.html">UNION</a></td><td align="left">UNION中的第二个或后面的SELECT</td></tr><tr><td align="left">DEPENDENT UNION</td><td align="left">UNION中的第二个或后面的SELECT，依赖于外层查询</td></tr><tr><td align="left">UNION RESULT</td><td align="left">UNION的结果</td></tr><tr><td align="left"><a href="https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-subquery">SUBQUERY</a></td><td align="left">子查询，SELECT中的第一个子查询</td></tr><tr><td align="left">DEPENDENT SUBQUERY</td><td align="left">依赖子查询，SELECT中的第一个子查询，依赖外层查询</td></tr><tr><td align="left">DERIVED</td><td align="left">FROM中的子查询（派生表）</td></tr><tr><td align="left">DEPENDENT DERIVED</td><td align="left">依赖于其他表的派生表</td></tr><tr><td align="left">MATERIALIZED</td><td align="left">具体化子查询</td></tr><tr><td align="left">UNCACHEABLE SUBQUERY</td><td align="left">无缓存的子查询，该子查询结果不能缓存，并且必须为外部查询的每一行重新计算</td></tr><tr><td align="left">UNCACHEABLE UNION</td><td align="left">UNION中的第二个或后面的SELECT，该SELECT属于一个无缓存子查询 （见<code>UNCACHEABLE SUBQUERY</code>）</td></tr></tbody></table><p><strong>table</strong></p><ul><li>&lt;unionM,N&gt;：id为M和N的查询的union</li><li>&lt;derivedN&gt;：当前查询依赖于id为N的查询</li><li>&lt;subqueryN&gt;：当前查询依赖于id为N的具体化子查询</li></ul><p><strong>type</strong></p><ul><li><p>system：只有一行的表</p></li><li><p>const：最多匹配一行，当PRIMARY KEY或UNIQUE索引与常量值进行比较时</p><ul><li><p>&#96;&#96;&#96;mysql<br>SELECT * FROM tbl_name WHERE primary_key&#x3D;1;</p><p>SELECT * FROM tbl_name<br>  WHERE primary_key_part1&#x3D;1 AND primary_key_part2&#x3D;2;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- eq_ref：最多只匹配一行，PRIMARY KEY或UNIQUE非空索引的所有部分都被join使用 ，索引使用等号=匹配</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    SELECT * FROM ref_table,other_table</span><br><span class="line">      WHERE ref_table.key_column=other_table.column;</span><br><span class="line">    </span><br><span class="line">    SELECT * FROM ref_table,other_table</span><br><span class="line">      WHERE ref_table.key_column_part1=other_table.column</span><br><span class="line">      AND ref_table.key_column_part2=1;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ref：可匹配多行，join只使用普通索引的部分前缀，或者key不是PRIMARY KEY或UNIQUE索引（即可能匹配多行）</p></li><li><p>fulltext：join使用FULLTEXT索引</p></li><li><p>ref_or_null：与ref相似，但允许值为null</p></li><li><p>index_merge：索引合并优化</p></li><li><p>unique_subquery：使用IN子查询时，代替eq_ref</p><ul><li>&#96;&#96;&#96;mysql<br>value IN (SELECT primary_key FROM single_table WHERE some_expr)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- index_subquery：与unique_subquery相似，但子查询的列不是主键或唯一索引</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    value IN (SELECT key_column FROM single_table WHERE some_expr)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>range：使用索引选择行，只检索给定范围内的行，当值与常数进行比较操作时使用（&#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, LIKE, or IN()）</p></li><li><p>index：与ALL相似，不同点在于索引树是否被扫描，有以下两种方式：</p><ul><li>如果索引是覆盖索引，而且能匹配所有需要的数据，那么只有索引树被扫描，Extra中显示Using index，通常比ALL快</li><li>执行全表扫描，使用从索引读取数据，按索引顺序查找数据行。Extra中不显示Using index</li></ul></li><li><p>ALL：全表扫描，通常可以添加索引来优化</p></li></ul><p>17、<strong>分布式事务</strong>：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p><p><strong>一致性</strong></p><ul><li>强一致性：任何一次读都能读到某个数据的最新数据，在任意时刻，所有节点中的数据是一样的</li><li>弱一致性：数据更新后，能容忍后续的访问只能访问到部分或者全部访问不到</li><li>最终一致性：不保证任意时刻所有节点数据都一致，但在一段时间后，节点间的数据会最终达到一致状态</li></ul><p><strong>CAP原则</strong>：在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><p><strong>BASE理论</strong>：Basically Available Soft State Eventual Consistency</p><ul><li>BA：Basically Available 基本可用，分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li><li>S：Soft State 软状态，允许系统存在中间状态，而该中间状态不会影响系统整体可用性。</li><li>E：Consistency 最终一致性，系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li><li>BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充。</li></ul><p><strong>分布式事务解决方案</strong></p><p><strong>2PC</strong>：两阶段提交，准备阶段-提交阶段</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/XA-first.jpg" class title="img"><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/XA-second.jpg" class title="img"><p><strong>3PC</strong>：准备阶段-预提交阶段-提交阶段</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/v2-885daf4ba34102d6e1047b0b67910652_720w.jpg" class title="img"><p><strong>TCC</strong>（Try-Confirm-Cancel）：尝试-确认-取消，可以跨数据库、跨不同的业务系统来实现事务。</p><ul><li>Try：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）</li><li>Confirm：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。</li><li>Cancel：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性，Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。</li></ul><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/v2-90179fa933c0a389ffa6ac04e244a58f_720w.jpg" class title="img"><p><strong>本地消息表</strong>：将需要分布式处理的任务通过消息日志的方式来异步执行，利用各系统本地事务来实现分布式事务。假设系统 A 是消息生产者，系统 B 是消息消费者，大致流程如下：</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/native-message.jpg" class title="img"><ol><li>当系统 A 被其他系统调用发生数据库表更新操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中（保证业务和消息是同步的）</li><li>系统 A 的脚本定期轮询本地消息往 MQ 中写入一条消息，如果消息发送失败会进行重试</li><li>系统 B 消费 MQ  中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 MQ 中的消息进行重试，如果业务上的失败，可以通知系统 A 进行回滚操作</li></ol><p><strong>消息事务</strong>：不使用本地消息表，直接对消息队列中间件操作，阿里的RocketMQ支持消息事务</p><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/v2-72ba7bed684e855606c44ddda185987d_720w.jpg" class title="img"><p>RocketMQ 的发送方会提供一个<strong>反查事务状态接口</strong>，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。</p><p><strong>最大努力通知</strong>：最大努力通知是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。</li></ol><blockquote><p><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></p></blockquote><p>18、堆（优先队列）的特点</p><p>堆顶是整个树的最大值或最小值，每个子树的根节点也是子树的最大值或最小值</p><p>19、MyBatis理解，ORM？</p><p>MyBatis是ORM（Object Relational Mapping，对象 - 关系映射）框架，主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。</p><p>20、BIO，NIO</p><p>编程：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">3. 无重复字符的最长子串</a></p><h2 id="美团打车-一面-8-x2F-19">1.13. 美团打车 一面 8&#x2F;19</h2><p>1、Bean注入的方式</p><p>（1）构造器注入</p><p>（2）set注入</p><p>（3）</p><p>2、ThreadLocal使用的场景</p><p>（1）代替参数的显式传递：将参数存储在ThreadLocal中，Service的方法就不需要传参</p><p>（2）全局存储用户信息：每个连接是一个线程，每个线程可以存自己的用户信息，在这个线程运行期间，直接从ThreadLocal中获取</p><p>（3）解决线程安全问题：数据库连接中利用了ThreadLocal，每一个请求线程都保存有一份自己的Connection</p><p>3、Redis持久化机制</p><p>目的：将内存中的数据写入硬存，断电之后数据还能保存，用于数据恢复或备份</p><p><strong>快照（RDB）</strong>，默认方式</p><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。一段时间内，如果有一定数量的key发生变化，就会启动快照方式保存数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure><p><strong>追加文件（append-only file, AOF）</strong></p><p>每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>Redis 的配置文件中的 AOF 持久化方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><p>4、用户不断发请求，这个请求不在缓存中，也不在数据库中，如何避免数据库负载？</p><p>（1）缓存无效key：如果不在数据库中，则添加一个缓存，缓存里面的值是错误信息，之后用户就可以直接从缓存返回，不会查询数据库</p><p>（2）布隆过滤器：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走查缓存和数据库的流程。</p><p><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p>5、当类之间有相互依赖时，Spring如何注入Bean，比如类A依赖类B，类B依赖类A</p><p>spring中循环依赖有三种情况：</p><p>（1）<strong>构造器注入形成的循环依赖。</strong>beanB需要在beanA的构造函数中完成初始化，beanA也需要在beanB的构造函数中完成初始化，这种情况的结果就是两个bean都不能完成初始化，循环依赖难以解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> A&#123;</span><br><span class="line">    B b;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> B&#123;</span><br><span class="line">    A a;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/885859-20200508180615793-1149903775.png" class title="img"><p>（2）<strong>setter注入构成的循环依赖。</strong>beanA需要在beanB的setter方法中完成初始化，beanB也需要在beanA的setter方法中完成初始化，spring设计的机制主要就是解决这种循环依赖，也是今天下文讨论的重点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/07/2022%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/885859-20200508180602441-272857363.png" class title="img"><p>（3）<strong>prototype作用域bean的循环依赖。</strong>这种循环依赖同样无法解决，因为spring不会缓存‘prototype’作用域的bean，而spring中循环依赖的解决正是通过缓存来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring对单例setter注入循环依赖的解决方法：</p><p>（1）初始化A，通过构造函数创建了一个单例对象，并将此对象缓存下来，还未执行setter方法；</p><p>（2）准备对B进行setter注入，对B进行初始化；</p><p>（3）初始化B，发现依赖A，对A初始化，发现A已经初始化，则从缓存中拿到A的引用，B完成setter注入，此时B在Ioc容器中生成；</p><p>（4）A从Ioc容器中获取B，对B进行setter注入，A初始化完成。</p><p>编程：</p><p>1、判断回文串</p><p>2、判断最长回文子串</p><h2 id="美团打车-二面-8-x2F-26">1.14. 美团打车 二面 8&#x2F;26</h2><p>1、项目</p><p>2、论文，栈优化</p><p>编程：</p><p>1、Z型输出矩阵</p><p>反问：</p><p>1、美团安全治理方面</p><p>2、Java栈</p><h2 id="微软-一面-9-x2F-19">1.15. 微软 一面 9&#x2F;19</h2><p>编程：</p><p>1、循环房屋盗窃</p><h2 id="招银网络科技-一面-9-x2F-19">1.16. 招银网络科技 一面 9&#x2F;19</h2><p>1、mysql语句</p><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student`(</span><br><span class="line">`id` VARCHAR(10) NOT NULL,</span><br><span class="line">`name` VARCHAR(20) NOT NULL,</span><br><span class="line">    `age` INT(20) NOT NULL,</span><br><span class="line">    PRIMARY KEY(`id`)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>查询最后一次插入的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT `id` FROM `student` WHERE `name` = &#x27;xxx&#x27; LIMITE 0,1;</span><br></pre></td></tr></table></figure><p>2、ArrayList和LinkedList区别</p><p>3、Set如何判断重复</p><p>4、代理模式</p><p>5、单例模式</p><h2 id="广东省农信-一面-9-x2F-21">1.17. 广东省农信 一面 9&#x2F;21</h2><p>MySQL检查是否使用索引</p><h2 id="阿里-一面-9-x2F-21">1.18. 阿里 一面 9&#x2F;21</h2><p>1、大数据流中寻找最大的k个数</p><p>2、堆的数据结构</p><p>3、堆排序为什么是nlogn</p><p>4、多线程并发问题</p><p>5、线程传递值</p><p>6、线程池</p><p>7、ThreadLocal底层实现</p><p>8、使用ThreadLocal需要注意什么问题？</p><p>9、强引用、软引用、弱引用、虚引用</p><p><strong>强引用</strong>：直接<code>new</code>的对象都是强引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o = new Object();</span><br></pre></td></tr></table></figure><p>只要某个对象有强引用与之关联，这个对象永远不会被回收，即使内存不足，JVM宁愿抛出OOM，也不会去回收。</p><p>若要让其回收，只需要设置为null，这样对象就没有引用可以到达。</p><p><strong>软引用</strong>：通过<code>SoftReference</code>包装的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SoftReference studentSoftReference = new SoftReference(new Student());</span><br><span class="line">Student student = studentSoftReference.get();</span><br></pre></td></tr></table></figure><p>如果内存不足时，触发GC后，如果内存仍然不足，则会回收软引用。</p><p>使用场景：比较适合用作缓存，当内存足够，可以正常的拿到缓存，当内存不够，就会先干掉缓存，不至于马上抛出OOM。</p><p><strong>弱引用</strong>：通过<code>WeakReference</code>包装的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;byte[]&gt;(new byte[1024*1024*10]);</span><br></pre></td></tr></table></figure><p>只要发生GC，无论内存是否充足，弱引用会被回收。</p><p><strong>虚引用</strong>：通过<code>PhantomReference</code>包装的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = new ReferenceQueue();</span><br><span class="line">PhantomReference&lt;byte[]&gt; reference = new PhantomReference&lt;byte[]&gt;(new byte[1], queue);</span><br></pre></td></tr></table></figure><p>虚引用必须与<code>ReferenceQueue</code>一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的队列中。</p><p>作用：跟踪回收对象，清理相关资源。NIO中，就运用了虚引用管理堆外内存。</p><p>10、Redis用来做什么？</p><p>11、为什么使用缓存</p><p>12、Redis使用应该注意什么？会出现什么问题？</p><p>13、缓存雪崩是什么？如何解决？</p><p>14、热搜怎么实现？底层数据结构是什么？</p><p>Redis的sorted set实现，底层是红黑树</p><p>15、消息队列用来做什么？</p><p>发布-订阅模式，削峰限流，异步处理</p><p>16、消息堆积，应该如何处理？</p><p>17、索引使用的原则</p><p>最左匹配原则</p><p>18、查询age大于28的男性，应该怎么设置索引？</p><p>19、项目中运用到什么设计模式？</p><p>20、类加载的双亲委派模型</p><p>编程：</p><p>1、<a href="https://leetcode.cn/problems/find-duplicate-subtrees/">寻找重复子树</a></p><p>2、排列组合</p><h2 id="微软-二面-9-x2F-22">1.19. 微软 二面 9&#x2F;22</h2><p>1、项目的数据表设计</p><p>2、查询每个月卖出最多5个用户</p><p>3、下订单的Restful API是什么样</p><h2 id="华为-一面-二面-9-x2F-22">1.20. 华为 一面 二面 9&#x2F;22</h2><p>1、访问百度时，整个ip转发的过程</p><p>2、项目需求是怎么做的</p><p>3、做项目的过程，如何推进功能</p><p>4、遇到问题和反馈时，如何解决</p><p>5、项目难点</p><p>编程：</p><p>1、模拟内存分配</p><p>2、链表排序，时间复杂度O(nlogn)，空间复杂度O(1)</p><h2 id="intel-一面-10-x2F-11">1.21. intel 一面 10&#x2F;11</h2><p>对称加密和非对称加密</p><p>数字签名</p><p>对签名的攻击</p><p>哈希表是什么</p><p>处理哈希表冲突的方法</p><p>头文件为什么要加上<code>#define</code>？</p><p><code>extern</code>有什么作用？</p><p>指针是什么</p><p>平衡二叉树，插入时如何旋转？</p><p>编程：</p><p>1、归并排序</p><p>2、非递归，归并排序</p><p>反问：</p><p>intel flex</p><p>本身没有项目，内包部门，与其他部门做项目，相当于临时工</p><h2 id="intel-二面-10-x2F-11">1.22. intel 二面 10&#x2F;11</h2><p>hr英文面，直接寄</p><h2 id="招银网络-二面-10-x2F-11">1.23. 招银网络 二面 10&#x2F;11</h2><p>1、Redis缓存雪崩，缓存击穿，缓存穿透，解决方法</p><p>2、为什么要用双亲委派机制？</p><p>保证每一个类在各个类加载器中都是同一个类。</p><p>保证<code>java</code>官方的类库<code>&lt;JAVA_HOME&gt;\lib</code>和扩展类库<code>&lt;JAVA_HOME&gt;\lib\ext</code>的加载安全性，不会被开发者覆盖。</p><p>3、Spring和SpringBoot区别</p><p>4、哈希的作用</p><p>5、Redis集群，用hash均匀分配数据，若要扩容，增加Redis服务器，那么应该怎么做？</p><p>环形hash?</p><p>6、MyBatis如何添加额外的映射，如类中有枚举对象，如何映射到数据库？</p><p>7、员工考核系统，如何设计数据库</p><p>8、如何设计系统权限</p><p>9、你有什么其他优点？</p><h2 id="阿里-一面-10-x2F-13">1.24. 阿里 一面 10&#x2F;13</h2><p>编程：LRU</p><p>设计模式，单例模式实现方式有哪些</p><p>服务器死机的问题，如何解决，如何debug</p><p>SpringBoot与Spring的区别</p><p>自动装配的实现</p><p>学习一个新知识，你的学习过程</p><p>MySQL一张表的最大容量是多少，超过多少性能会下降 </p><p>海量数据如何存储，工程上如何实现</p><p>使用过大数据分析吗，如Hadoop，分析策略上与一般数据库有什么不同</p><p>负载均衡如何实现</p><p>微服务是什么</p><h2 id="中国电信-一面-10-x2F-19">1.25. 中国电信 一面 10&#x2F;19</h2><p>有没有用过其他开源数据库</p><p>网络安全攻防了解吗</p><p>python和C会吗</p><p>成绩真的有前10%吗？</p><h2 id="中国移动-一面-10-x2F-19">1.26. 中国移动 一面 10&#x2F;19</h2><h2 id="深圳智慧城市-一面-10-x2F-22">1.27. 深圳智慧城市 一面 10&#x2F;22</h2><h2 id="平安金服-一面-10-x2F-24">1.28. 平安金服 一面 10&#x2F;24</h2><p>MySQL索引设计要注意什么</p><p>MySQL的日志</p><p>JAVA集合类</p><p>如何理解面向抽象</p><p>设计模式</p><p>微服务设计</p><p>对银行业务了解吗</p><p>自己最大的优点是什么</p><p>架构师需要什么能力</p><h2 id="中兴-二面-10-x2F-28">1.29. 中兴 二面 10&#x2F;28</h2><p>C++的局部变量存储在哪里</p><p>linux做过什么，做过网络编程吗</p><p>大端存储和小端存储，单位是什么？</p><h2 id="携程-一面-10-x2F-28">1.30. 携程 一面 10&#x2F;28</h2><p>1、高并发需求，应该如何设计，使用什么技术？</p><p>2、Ribbon负载均衡如何实现的</p><p>3、项目的安全问题，认证问题如何解决</p><p>4、Spring Cloud相关组件使用</p><p>5、多并发编程需要注意什么</p><p>6、线程如何创建？除了线程池还有什么方式？</p><ul><li>Thread</li><li>实现Runnable</li><li>实现Callable</li><li>ThreadPoolExecutor线程池</li></ul><p>7、如何实现高并发？</p><h2 id="携程-二面-11-x2F-1">1.31. 携程 二面 11&#x2F;1</h2><p>1、项目</p><p>2、如何拆分微服务</p><p>3、你被困在一个房间，要待上10天，房间里面有毒气，现在给你一瓶A药和一瓶B药，他们分别有10片药片，每天需要吃一片A和一片B才能活下来，如果你打翻了两个瓶子，A药片和B药片混在了一起且无法区分，你要如何撑过10天？</p>]]></content>
    
    
    <summary type="html">阿里、字节、美团面经</summary>
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM介绍</title>
    <link href="http://example.com/2022/02/22/JVM%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/02/22/JVM%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-02-22T06:13:09.000Z</published>
    <updated>2022-10-31T10:25:40.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域">1. Java内存区域</h1><p>Java程序运行时，内存区域可分为线程私有区域和线程共享区域</p><h2 id="线程私有">1.1. 线程私有</h2><p>程序计数器（PC）：用于存储下一个指令的地址</p><p>Java虚拟机栈：为虚拟机执行 Java 方法服务，存储局部变量表、操作数栈、动态链接、方法出口信息</p><p>本地方法栈：为本地方法<strong>（Native方法）</strong>服务，存储本地方法的局部变量表、操作数栈、动态链接、方法出口信息</p><h2 id="线程共享">1.2. 线程共享</h2><p>堆：存储对象实例</p><p>方法区（JDK1.8后变成<strong>元空间</strong>）：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><p>直接内存：不是运行时的内存区域</p><h1 id="JVM垃圾回收">2. JVM垃圾回收</h1><h2 id="内存分配与回收">2.1. 内存分配与回收</h2><h3 id="堆空间">2.1.1. 堆空间</h3><p>新生代：Eden，From Survivor0，To Survivor1</p><p>老年代：Old Memory</p><span id="more"></span> <h3 id="内存分配流程">2.1.2. 内存分配流程</h3><p><strong>大多数情况下，对象在新生代中 Eden 区分配</strong>。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <strong>Minor GC</strong>，若仍没有足够空间，则只好通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去。</p><blockquote><p><strong>空间分配担保机制</strong>：为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p></blockquote><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率，<strong>大对象直接进入老年代</strong>，大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>长期存活的对象进入老年代</strong>。对象在 Eden 区出生，初始年龄为0；经过一次 Minor GC 后，进入 Survivor，年龄为1；之后每经过一次 Minor GC，若仍存活，年龄都会增大一岁，默认到达15岁就会进入到老年代。</p><h3 id="GC分类">2.1.3. GC分类</h3><p>针对 HotSpot VM 的实现， GC 分为两大种：</p><ul><li>部分收集 (Partial GC)：<ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li></ul><h2 id="判断对象是否死亡">2.2. 判断对象是否死亡</h2><h3 id="引用计数法">2.2.1. 引用计数法</h3><p>每个对象都添加一个引用计数器，该对象每有一个引用时加1，一个引用失效时减1，当计数器的值为0时表示该对象死亡。</p><p>优点：实现简单，效率高</p><p>缺点：<strong>无法解决对象之间相互循环引用的问题</strong>。A和B相互引用，此外没有其他引用，当A和B使用完毕时，本应该回收，但由于他们相互引用，他们的引用计数器都不为0，则无法回收</p><h3 id="可达性分析算法">2.2.2. 可达性分析算法</h3><p>以 <strong>GC Roots</strong> 为根结点构建一个引用树，每个结点的引用路径就是从根结点到该结点的路径，若结点不在这个引用树中，则表示对象不可用，需要被回收。</p><p><strong>可以作为 GC Roots 的对象</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="判断常量是否为废弃常量">2.2.3. 判断常量是否为废弃常量</h3><p>如果常量没有任何引用，则为废弃常量。</p><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="判断类是否为无用类">2.2.4. 判断类是否为无用类</h3><p>同时满足以下3个条件的类为无用类：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="垃圾收集算法">2.3. 垃圾收集算法</h2><blockquote><p>图片引用自<a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/">https://javaguide.cn/java/jvm/jvm-garbage-collection/</a></p></blockquote><h3 id="标记-清除算法">2.3.1. 标记-清除算法</h3><p>标记存活的对象，然后清除未标记的对象</p><p>问题：效率问题，空间问题（产生大量碎片）</p><img src="/2022/02/22/JVM%E4%BB%8B%E7%BB%8D/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.65bd8fdd.jpeg" class title="img"><h3 id="标记-复制算法">2.3.2. 标记-复制算法</h3><p>将内存分为两大块，每次使用其中的一块，当这一块内存使用完后，标记存活的对象，然后将标记的对象复制到另一块内存（连续存放在另一块内存的首部），最后清除掉之前那块内存。</p><img src="/2022/02/22/JVM%E4%BB%8B%E7%BB%8D/90984624.fed0b8a5.png" class title="复制算法"><h3 id="标记-整理算法">2.3.3. 标记-整理算法</h3><p>标记存活的对象，将标记的对象全部移动到内存首部，然后清理其他内存。</p><img src="/2022/02/22/JVM%E4%BB%8B%E7%BB%8D/94057049.6e404020.png" class title="标记-整理算法"><h3 id="分代收集算法">2.3.4. 分代收集算法</h3><p>新生代：每次收集都会有大量对象死去，所以可以选择 <strong>标记-复制算法</strong></p><p>老年代：年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 <strong>标记-清除</strong> 或 <strong>标记-整理</strong> 算法进行垃圾收集</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java内存区域&quot;&gt;1. Java内存区域&lt;/h1&gt;&lt;p&gt;Java程序运行时，内存区域可分为线程私有区域和线程共享区域&lt;/p&gt;
&lt;h2 id=&quot;线程私有&quot;&gt;1.1. 线程私有&lt;/h2&gt;&lt;p&gt;程序计数器（PC）：用于存储下一个指令的地址&lt;/p&gt;
&lt;p&gt;Java虚拟机栈：为虚拟机执行 Java 方法服务，存储局部变量表、操作数栈、动态链接、方法出口信息&lt;/p&gt;
&lt;p&gt;本地方法栈：为本地方法&lt;strong&gt;（Native方法）&lt;/strong&gt;服务，存储本地方法的局部变量表、操作数栈、动态链接、方法出口信息&lt;/p&gt;
&lt;h2 id=&quot;线程共享&quot;&gt;1.2. 线程共享&lt;/h2&gt;&lt;p&gt;堆：存储对象实例&lt;/p&gt;
&lt;p&gt;方法区（JDK1.8后变成&lt;strong&gt;元空间&lt;/strong&gt;）：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据&lt;/p&gt;
&lt;p&gt;直接内存：不是运行时的内存区域&lt;/p&gt;
&lt;h1 id=&quot;JVM垃圾回收&quot;&gt;2. JVM垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;内存分配与回收&quot;&gt;2.1. 内存分配与回收&lt;/h2&gt;&lt;h3 id=&quot;堆空间&quot;&gt;2.1.1. 堆空间&lt;/h3&gt;&lt;p&gt;新生代：Eden，From Survivor0，To Survivor1&lt;/p&gt;
&lt;p&gt;老年代：Old Memory&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HTTP常见错误代码</title>
    <link href="http://example.com/2022/02/15/HTTP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2022/02/15/HTTP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81/</id>
    <published>2022-02-15T09:38:05.000Z</published>
    <updated>2022-10-31T10:25:40.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1XX（临时响应）">1. 1XX（临时响应）</h1><p>表示临时响应并需要请求者继续执行操作的状态代码。</p><table><thead><tr><th>代码</th><th>简要说明</th><th>详细说明</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr></tbody></table><h1 id="2XX（成功）">2. 2XX（成功）</h1><p>表示成功处理了请求的状态代码。</p><table><thead><tr><th>代码</th><th>简要说明</th><th>详细说明</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接收</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分 GET 请求</td></tr></tbody></table><h1 id="3XX（重定向）">3. 3XX（重定向）</h1><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><table><thead><tr><th>代码</th><th>简要说明</th><th>详细说明</th></tr></thead><tbody><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</td></tr><tr><td>301</td><td>永久移动</td><td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</td></tr><tr><td>302</td><td>临时移动</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</td></tr><tr><td>303</td><td>查看其他位置</td><td>请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</td></tr><tr><td>304</td><td>未修改</td><td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</td></tr><tr><td>305</td><td>使用代理</td><td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</td></tr><tr><td>307</td><td>临时重定向</td><td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</td></tr></tbody></table><h1 id="4XX（请求错误）">4. 4XX（请求错误）</h1><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><table><thead><tr><th>代码</th><th>简要说明</th><th>详细说明</th></tr></thead><tbody><tr><td>400</td><td>错误请求</td><td>服务器不理解请求的语法</td></tr><tr><td>401</td><td>未授权</td><td>请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的网页</td></tr><tr><td>405</td><td>方法禁用</td><td>禁用请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容特性响应请求的网页</td></tr><tr><td>407</td><td>需要代理授权</td><td>此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</td></tr><tr><td>408</td><td>请求超时</td><td>服务器等候请求时发生超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</td></tr><tr><td>410</td><td>已删除</td><td>如果请求的资源已永久删除，服务器就会返回此响应</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>服务器无法处理请求，因为请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求的URI过长</td><td>请求的 URI（通常为网址）过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持的媒体类型</td><td>请求的格式不受请求页面的支持</td></tr><tr><td>416</td><td>请求范围不符合要求</td><td>如果页面无法提供请求的范围，则服务器会返回此状态代码</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足”期望”请求标头字段的要求</td></tr></tbody></table><h1 id="5XX（服务器错误）">5. 5XX（服务器错误）</h1><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><table><thead><tr><th>代码</th><th>简要说明</th><th>详细说明</th></tr></thead><tbody><tr><td>500</td><td>服务器内部错误</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>尚未实施</td><td>服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求</td></tr><tr><td>505</td><td>HTTP版本不支持</td><td>服务器不支持请求中所用的 HTTP 协议版本</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">HTTP常见错误代码，1XX（临时响应），2XX（成功），3XX（重定向），4XX（请求错误），5XX（服务器错误）</summary>
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>密码工程资料</title>
    <link href="http://example.com/2021/09/26/%E5%AF%86%E7%A0%81%E5%B7%A5%E7%A8%8B%E8%B5%84%E6%96%99/"/>
    <id>http://example.com/2021/09/26/%E5%AF%86%E7%A0%81%E5%B7%A5%E7%A8%8B%E8%B5%84%E6%96%99/</id>
    <published>2021-09-26T02:44:13.000Z</published>
    <updated>2022-03-01T07:05:21.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIST第三轮算法：">1. NIST第三轮算法：</h1><p><a href="https://csrc.nist.gov/projects/post-quantum-cryptography/round-3-submissions">https://csrc.nist.gov/projects/post-quantum-cryptography/round-3-submissions</a><br>主要关注：KEM中的Kyber、Saber、NTRU，签名中的Dilithium</p><h1 id="格密码理论知识：">2. 格密码理论知识：</h1><ol><li>NIST提案中各算法的文档，了解这些算法的数据结构和流程</li><li>Chris Peikert主页：<a href="http://web.eecs.umich.edu/~cpeikert/">http://web.eecs.umich.edu/~cpeikert/</a></li><li>Peter Schwabe主页：<a href="https://cryptojedi.org/peter/index.shtml">https://cryptojedi.org/peter/index.shtml</a></li><li>全国密码技术竞赛第二轮算法文档：<a href="https://sfjs.cacrnet.org.cn/site/term/list_77_1.html%EF%BC%8C%E4%BA%86%E8%A7%A3AKCN%E3%80%81Aigis">https://sfjs.cacrnet.org.cn/site/term/list_77_1.html，了解AKCN、Aigis</a></li></ol><h1 id="软件实现：">3. 软件实现：</h1><ol><li>AVX2指令集：<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2">https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2</a></li><li>ARM Cortex-M4指令集：<a href="https://developer.arm.com/documentation/ddi0439/b/Programmers-Model/Instruction-set-summary/Cortex-M4-instructions">https://developer.arm.com/documentation/ddi0439/b/Programmers-Model/Instruction-set-summary/Cortex-M4-instructions</a></li><li>计算机架构底层优化：<a href="https://www.agner.org/optimize/">https://www.agner.org/optimize/</a></li></ol><h1 id="D-J-B主页：">4. D.J.B主页：</h1><p><a href="https://cr.yp.to/djb.html">https://cr.yp.to/djb.html</a></p><h1 id="论文获取：">5. 论文获取：</h1><p><a href="https://eprint.iacr.org/complete/">https://eprint.iacr.org/complete/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NIST第三轮算法：&quot;&gt;1. NIST第三轮算法：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://csrc.nist.gov/projects/post-quantum-cryptography/round-3-submissions&quot;&gt;https://csrc</summary>
      
    
    
    
    <category term="密码学" scheme="http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何在github上搭博客</title>
    <link href="http://example.com/2021/09/22/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/09/22/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-09-22T11:48:01.000Z</published>
    <updated>2022-03-01T07:05:21.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考网站">1. 参考网站</h1><p>Hexo官网 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><p>NexT教程 <a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></p><p>NexT模板 <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p><h1 id="Github设置">2. Github设置</h1><p>前提拥有github账号，配置好ssh连接</p><ol><li>创建一个仓库，命名方式：用户名.github.io</li><li>Settings-&gt;Pages-&gt;Source选择主分支</li><li>下面将使用Hexo工具来上传网页</li></ol><h1 id="Hexo使用">3. Hexo使用</h1><p>&#x2F;_config.yml称为<strong>站点配置文件</strong></p><p>&#x2F;themes&#x2F;theme&#x2F;_config.yml称为<strong>主题配置文件</strong></p><h2 id="安装">3.1. 安装</h2><ol><li>安装Node.js</li><li>使用npm安装hexo</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure><ol start="3"><li>初始化hexo站点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在指定文件夹中初始化一个hexo站点</span><br><span class="line">npx hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ol start="4"><li>安装NexT主题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><ol start="5"><li>启用主题</li></ol><p>在站点配置文件，找到theme字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next // 将主题改为next</span><br></pre></td></tr></table></figure><ol start="6"><li>本地验证主题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hexo server --debug // 开启hexo服务</span><br></pre></td></tr></table></figure><ol start="7"><li>生成静态文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hexo generate</span><br></pre></td></tr></table></figure><ol start="8"><li>部署到github</li></ol><p>修改站点配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:herfrain/herfrain.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>使用命令上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure><h2 id="引用资源">3.2. 引用资源</h2><h3 id="不能使用markdown的方法引用资源">3.2.1. 不能使用markdown的方法引用资源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image-20210922195056513.png image-20210922195056513 %&#125;</span><br></pre></td></tr></table></figure><p><code>&#123;% asset_img image-20210922195056513.png image-20210922195056513 %&#125;</code><br><code>![example](postname/example.jpg)</code></p><img src="/2021/09/22/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%8D%9A%E5%AE%A2/image-20210922195056513.png" class title="image-20210922195056513"><h3 id="要用标签插件来引用">3.2.2. 要用标签插件来引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img 图片.jpg 图片标题 %&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/22/%E5%A6%82%E4%BD%95%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%8D%9A%E5%AE%A2/image-20210922195056513.png" class title="图片1">]]></content>
    
    
    <summary type="html">Github + Hexo 实现个人博客</summary>
    
    
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>经典动态规划问题</title>
    <link href="http://example.com/2020/05/03/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/05/03/%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-03T08:39:33.000Z</published>
    <updated>2022-03-01T07:05:21.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最大连续子序列和">1. 最大连续子序列和</h1><p>给出一个数字序列{A1,A2,A3,…,An}，求i,j(1&lt;&#x3D;i&lt;&#x3D;j&lt;&#x3D;n)，使得Ai+…+Aj最大，并输出这个最大和。</p><p>如{-2,11,-4,13,-5,-2}<br>最大连续子序列和为 11+(-4)+13&#x3D;20</p><h2 id="结题思路">1.1. 结题思路</h2><p>1.设计状态：dp[i]表示以A[i]结尾的连续序列的最大和</p><p>2.找出关系 ：<br>因为dp[i]要求必须以A[i]为结尾，那么就有两种情况：<br>(1) 这个最大和只有一个元素，就是A[i]，dp[i]&#x3D;A[i]<br>(2) 这个最大和有多个元素，从A[p]到A[i](p&lt;i)，dp[i] &#x3D; dp[i-1] + A[i]</p><p>3.设计状态转移方程：<br>dp[i] &#x3D; max{A[i], dp[i-1]+A[i]}</p><h2 id="关键代码">1.2. 关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = Integer.MIN_VALUE; <span class="comment">//最大连续子序列和</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">dp[<span class="number">0</span>] = A[<span class="number">0</span>]; <span class="comment">//初始化dp[0]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = Math.max(A[i], dp[i - <span class="number">1</span>] + A[i]);</span><br><span class="line">    ans = Math.max(ans, dp[i]);<span class="comment">//取dp数组中的最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长不下降子序列（LIS）">2. 最长不下降子序列（LIS）</h1><p>在一个数字序列中，找到一个最长的子序列（可以不连续），这个子序列是非递减的</p><p>如{1,2,3,-1,-2,7,9}<br>最长不下降子序列为 {1,2,3,7,9}，长度为5</p><h2 id="结题思路-1">2.1. 结题思路</h2><p>1.设计状态：dp[i]表示以A[i]结尾的最长不下降子序列的长度</p><p>2.找出关系：<br>(1) 如果A[i]之前的元素全部都比A[i]大，那么dp[i]只能等于1<br>(2) 如果A[i]之前的元素A[j](j&lt;i)，有A[j]&lt;&#x3D;A[i]，找到其中最长的一个，然后加上A[i]，则dp[i]就是最长的</p><p>3.设计状态转移方程：<br>dp[i]&#x3D;max{1,dp[j]+1} (0&lt;&#x3D;j&lt;i&amp;&amp;A[j]&lt;&#x3D;A[i])<br>其中dp[j]是dp[0,i-1]中的最大值</p><h2 id="关键代码-1">2.2. 关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = -<span class="number">1</span>; <span class="comment">// 初始化ans</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="comment">// 初始化dp中的元素为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// 遍历[0,i-1]找出最大的满足A[i]&gt;=A[j]的dp[j]，然后更新</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt;= A[j] &amp;&amp; (dp[j] + <span class="number">1</span> &gt; dp[i])) &#123;</span><br><span class="line">            dp[i] = dp[j] + <span class="number">1</span>; <span class="comment">// 状态转移方程，更新dp[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = Math.max(ans, dp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子序列（LCS）">3. 最长公共子序列（LCS）</h1><p>给定两个字符串（或数字序列）A和B，求它们的最长公共子序列（可以不连续）</p><p>如A&#x3D;”sadstory”<br>B&#x3D;”adminsorry”<br>最长公共子序列为”adsory”，长度为6</p><h2 id="结题思路-2">3.1. 结题思路</h2><p>1.设计状态：dp[i][j] 表示字符串A的i号位和字符串B的j号位之前的LCS长度</p><p>2.找出关系：<br>(1) 若A[i]=&#x3D;B[i]，相当于在dp[i-1][j-1]的情况下多出一个相同字符，LCS长度增加，即dp[i][j]&#x3D;dp[i-1][j-1]+1<br>(2) 若A[i]!&#x3D;B[i]，则LCS长度没有增加，所以要继承前面的长度，前面的长度有两种，分别是dp[i-1][j]和dp[i][j-1]，所以取它们两个的最大值作为dp[i][j]的值，<br>即dp[i][j]&#x3D;max{dp[i-1][j] , dp[i][j-1]}</p><p>3.设计状态转移方程：<br>dp[i]&#x3D;dp[i-1][j-1]+1, A[i]=&#x3D;B[i]<br>dp[i]&#x3D;max{dp[i-1][j] , dp[i][j-1]} , A[i]!&#x3D;B[i] </p><h2 id="关键代码-2">3.2. 关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] A = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">char</span>[] B = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = (A[<span class="number">0</span>] == B[<span class="number">0</span>]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 初始化第一行和第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] == B[i]) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[j] == B[j]) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从(1,1)开始遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == B[i]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = dp[n][n];</span><br></pre></td></tr></table></figure><h1 id="最长回文子串">4. 最长回文子串</h1><p>给出一个字符串S，求S的最长回文子串的长度</p><p>如字符串”abcDDDccba”的最长回文子串是”cDDDc”，长度为5</p><h2 id="结题思路-3">4.1. 结题思路</h2><p>1.设计状态：dp[i][j] 表示S[i]到S[j]所表示的子串是否是回文子串，是则为1，不是则为0。dp[i][j]有初始的状态，单个字符时，一定是回文串（即dp[i][i]&#x3D;1）；两个字符时，如果相同则是回文串（即dp[i][i+1]&#x3D;(S[i]=&#x3D;S[i+1]):1?0）</p><p>2.找出关系：<br>根据S[i]是否等于S[j]，可以分为两类：<br>(1) 若S[i]=&#x3D;S[j]，如果[i+1,j-1]是回文串（即dp[i+1][j-1]&#x3D;1），那么[i,j]也是回文串（即dp[i][j]&#x3D;1）；如果[i+1,j-1]不是回文串，[i,j]就也不是回文串<br>(2) 若S[i]!&#x3D;S[j]，则[i,j]必然不是回文串</p><p>3.设计状态转移方程：<br>dp[i][j]&#x3D;dp[i+1][j-1]，S[i]=&#x3D;S[j]<br>dp[i][j]&#x3D;0，S[i]!&#x3D;S[j]<br>边界：dp[i][i]&#x3D;1， dp[i][i+1]&#x3D;(S[i]&#x3D;&#x3D;S[i+1]):1?0<br>因为[i,j]是根据[i+1,j-1]推出来的，即长的子串由短的子串推出，所以在迭代计算dp时，可以按长度递增的顺序不断推出较长的子串</p><h2 id="关键代码-3">4.2. 关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcDDDccba&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="keyword">char</span>[] S = str.toCharArray();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len]; <span class="comment">// 初始化全为0</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>; <span class="comment">// 记录最长回文子串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化单个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化两个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S[i] == S[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        dp[i][i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">2</span>; <span class="comment">// 如果有长度为2的回文子串，改变ans</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i][i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++) &#123; <span class="comment">// 长度从3开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + L - <span class="number">1</span>; <span class="comment">// i为左端，j为右端</span></span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123; <span class="comment">// 两端相等&amp;&amp;里面是回文子串</span></span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            ans = L;</span><br><span class="line">        &#125; <span class="comment">// 其余都为0，不需要改变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个简化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// i逆序</span></span><br><span class="line">    dp[i][i] = <span class="keyword">true</span>; <span class="comment">// 单个字符</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; S[i] == S[i + <span class="number">1</span>]) dp[i][i + <span class="number">1</span>] = <span class="keyword">true</span>; <span class="comment">// 两个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; len; j++) &#123; <span class="comment">// j正序</span></span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="keyword">true</span>) &#123; <span class="comment">// 两端相等&amp;&amp;里面是回文子串</span></span><br><span class="line">            dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">经典动态规划问题：最大连续子序列和、最长不下降子序列、最长公共子序列、最长回文子串</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2020笔试题总结</title>
    <link href="http://example.com/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-26T02:26:21.000Z</published>
    <updated>2022-03-01T07:05:21.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="招商银行">1. 招商银行</h1><p>1.FTP两种模式</p><ul><li><p>ASCII传输模式</p></li><li><p>二进制数据传输模式</p></li></ul><p>2.MongoDB是关系型数据库吗？</p><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>3.java中Calendar类的设计模式</p><p>工厂模式 Calendar.getInstance()</p><p>4.聚集索引</p><p>数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况</p><p>5.mysql语句中 is not null与 !&#x3D;null，哪个是正确的？</p><p>应使用<strong>is not null</strong>，null不能用&#x3D;或!&#x3D;来比较（不会显示编译错误，永远返回0行）</p><p>6.CSS父元素继承</p><ul><li>不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。</li><li>所有元素可继承：visibility和cursor。</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。</li><li>终端块状元素可继承：text-indent和text-align。</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</li><li>表格元素可继承：border-collapse。</li></ul><p>7.条件覆盖</p><p>不仅程序中的每个语句至少被执行一次，而且使每个判定表达式中的每个条件都取到各种可能的结果。</p><p>8.HTTP中401表示？</p><p>表示未授权</p><p>9.多道程序设计，OS&#x2F;2，DOS？</p><p>DOS操作系统没有多道程序设计的特点</p><p>10.获取div文本内容</p><p>$(‘#id’).text()</p><p>11.视图的构造基于什么？</p><p>基本表</p><p>12.一个java文件可以包含多个class文件吗？</p><p>可以有多个.class文件，因为这个java文件中有多个class类，只有一个public class</p><p>13.防火墙，漏洞扫描？</p><p>14.python中复数（实部、虚部）写法</p><p>x+yj(或J)</p><p>15.java中如何正确停止一个线程</p><p>(1). 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p><p>(2). 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</p><p>(3). 使用interrupt方法中断线程。</p><p>16.数据证书</p><p>17.UML图包括哪些？</p><ul><li><p>用例图：从用户角度描述系统功能。</p></li><li><p>类图：描述系统中类的静态结构。</p></li><li><p>对象图：系统中的多个对象在某一时刻的状态。</p></li><li><p>状态图：是描述状态到状态控制流，常用于动态特性建模</p></li><li><p>活动图：描述了业务实现用例的工作流程</p></li><li><p>顺序图：对象之间的动态合作关系，强调对象发送消息的顺序，同时显示对象之间的交互</p></li><li><p>协作图：描述对象之间的协助关系</p></li><li><p>构件图：一种特殊的UML图来描述系统的静态实现视图</p></li><li><p>部署图：定义系统中软硬件的物理体系结构</p></li><li><p>包图：对构成系统的模型元素进行分组整理的图</p></li><li><p>组合结构图：表示类或者构建内部结构的图</p></li><li><p>交互概览图：用活动图来表示多个交互之间的控制关系的图</p></li></ul><p>18.python语句块靠什么分割</p><p>缩进</p><p>19.linux压缩和解压的命令</p><p>tar cvf 文件.tar 目录 - 压缩目录</p><p>tar xvf 文件.tar - 解压目录</p><p>zip 文件.zip 目录 - 压缩目录</p><p>unzip 文件.zip - 解压目录</p><p>rar a 文件.rar 目录 - 压缩目录</p><p>rar x 文件.rar - 解压目录</p><p>tar zcvf 文件.tar.gz 目录 - 压缩目录</p><p>tar zxvf 文件.tar.gz - 解压目录</p><p>gzip 文件名 - 压缩文件</p><p>gzip -d 文件名.gz - 解压文件</p><p>bzip2 -z 文件名 - 压缩文件</p><p>bzip2 -d 文件名.bz2 - 解压文件</p><p>tar -jcvf 文件.tar.bz2 目录 - 压缩目录</p><p>tar -jxvf 文件.tar.bz2 - 解压目录</p><h1 id="格力">2. 格力</h1><p>1.string-&gt;float</p><p>parseFloat(“2.41”);</p><p>2.JVM,JDK,JRE区别</p><ul><li>JDK&gt;JRE&gt;JVM</li><li>JDK（Java Development Kit）Java开发包：是功能齐全的Java SDK，包含JRE，还有编译器（javac）和工具（如javadoc和jdb）。能够创建和编译程序。</li><li>JRE（Java Running Environment）Java运行环境：是运行已编译Java程序所需的所有内容的集合，包括JVM、Java类库、Java命令和其他构建。能够运行已编译的Java程序，但不能创建新程序。</li><li>JVM（Java Virtual Machine）Java虚拟机：是运行Java字节码的虚拟机。JVM针对不同的操作系统有不同的实现，目的是使用相同的字节码文件，得出相同的结果。字节码和不同系统的JVM实现是“一次编译，到处运行”的关键。</li></ul><p>3.不能被重载的符号有哪些</p><p>4.不能用于linux进程通信</p><p>5.RR隔离，幻读，加锁</p><p>RR隔离：Repeatable Read 可重复读，一种隔离等级，一个事务重复读某个数据时，其他事务不能修改这个数据。</p><p>幻读：一种并发事务可造成的问题，A事务在重复读某些数据，B事务添加或删除了数据，使得A事务读的数据会变多或变少。</p><p>6.linux查看负载命令</p><p>top命令</p><p>7.批处理系统</p><ul><li><p>单道批处理系统：内存中始终保持一道作业。</p></li><li><p>多道批处理系统：运行多个程序同时进入内存，并运行它们在CPU中交替运行。中断处理使I&#x2F;O和CPU能并行运行。</p></li><li><p>分时操作系统：多个用户通过终端同时共享一台主机。</p></li></ul><p>8.XML与HTML的区别</p><ul><li>HTML：超文本标记语言</li><li>XML：可扩展标记语言</li><li>可扩展性上，XML可扩展，HTML不可扩展</li><li>语法上，XML比较严格，HTML不严格</li><li>可读性和维护性上：XML结构清晰便于维护，HTML难以阅读维护</li></ul><p>9.sleep()与wait()区别</p><ul><li><p>线程方法Thread.sleep()，Object类方法Object.wait()</p></li><li><p>sleep()：线程暂停指定时间，监控状态依然保持，到时间后自动恢复运行状态。不会释放对象锁。</p></li><li><p>wait()：线程释放对象锁，进入等待锁定池，只有该对象调用notify()后，线程才能获取对象锁进入运行状态。</p><p>(1) 每个对象都有一个锁来控制同步访问，Synchronized关键字可以和对象的锁交互，来实现同步方法或同步块。sleep()方法正在执行的线程主动让出CPU（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)。</p><p>(2) wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；</p><p>(3) sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；</p><p>(4) sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()&#x2F;notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态；</p></li></ul><p>10.大文件排序，外设上的排序</p><p>排序方法分成两大类：</p><ul><li><p>内排序法是指待排序记录存放在计算机随机存储器(内存)中进行的排序过程。</p></li><li><p>外排序法是指待排序的数量很大，以至于内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。（大文件排序，外设上的排序）</p></li></ul><p>11.synchronized底层优化涉及的锁（4种）</p><ul><li><p>偏向锁：目的是消除数据在无竞争情况下的同步原语。</p></li><li><p>轻量级锁：在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p></li><li><p>重量级锁：通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操</p></li><li><p>作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。</p></li><li><p>自旋锁：互斥同步对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入到内核态中完成，这些操作给系统的并发性能带来很大的压力。于是在阻塞之前，我们让线程执行一个忙循环（自旋），看看持有锁的线程是否释放锁，如果很快释放锁，则没有必要进行阻塞。</p></li></ul><p>12.网络拓扑结构</p><p>总线型拓扑、星型拓扑、环型拓扑、树型拓扑、网状拓扑、混合型拓扑</p><p>13.&amp;&amp;,+,!,&#x2F;的优先级</p><p>a&#x3D;6,b&#x3D;4,c&#x3D;2;</p><p>!(a-b)+c-1 &amp;&amp; b+c&#x2F;2 &#x3D; ?</p><p>Java中编译失败，C++中值为1</p><p>14.DNS域名解析过程</p><p>两种查询方式：递归查询，递归与迭代相结合查询</p><p>本地缓存-&gt;本机hosts文件-&gt;本地域名服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权限域名服务器</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212171743589.png" class title="image-20220212171743589"><p>15.InnoDB索引模型，主键索引与普通索引在查询上的区别</p><ul><li><p>B+树索引模型</p></li><li><p>主键索引也被称为聚簇索引,叶子节点存放的是整行数据</p></li><li><p>非主键索引被称为二级索引,叶子节点存放的是主键的值</p></li><li><p>如果根据主键查询, 只需要搜索ID这颗B+树</p></li><li><p>如果通过非主键索引查询, 需要先搜索k索引树, 找到对应的主键, 然后再到ID索引树搜索一次, 这个过程叫做回表.</p></li><li><p>总结, 非主键索引的查询需要多扫描一颗索引树, 效率相对更低.</p></li></ul><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212171857584.png" class title="image-20220212171857584"><h1 id="招银网络科技">3. 招银网络科技</h1><h2 id="客观题">3.1. 客观题</h2><p>1.TCP数据传输问题</p><p>2.关系型数据库优点</p><p>3.邻接链表，DFS遍历，时间复杂度</p><p>邻接链表：O(V+E)</p><p>邻接矩阵：O(V^2)</p><p>4.简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式区别</p><p>简单工厂模式：</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212172009957.png" class title="image-20220212172009957"><p>简单工厂模式与工厂方法模式的区别：</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212172015755.png" class title="image-20220212172015755"><p>抽象工厂模式中的产品族和产品等级结构：</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212172022495.png" class title="image-20220212172022495"><p>抽象工厂模式：</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212172027903.png" class title="image-20220212172027903"><p>建造者模式：</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212172033014.png" class title="image-20220212172033014"><p>简单工厂模式：没有抽象工厂，一个具体工厂根据传入参数来创建不同的产品</p><p>工厂方法模式：有抽象工厂，也有抽象产品，每个具体工厂生产一种具体产品</p><p>抽象工厂模式：有抽象工厂，也有抽象产品，与工厂方法模式不同的是，具体工厂可以生产多种产品</p><p>建造者模式：将一个产品分解成多个部分，建造者可以分别建造不同的部分，然后将他们组装成完整的产品，用户通过指挥者可以获取产品（指挥者隔离了用户和生产的过程，同时负责产品的生成）</p><p>5.设计模式中，不能扩展的</p><p>6.SQL，数据定义语言</p><p>7.排他锁的作用，加排他锁之后能读吗？</p><p>排他锁也叫写锁、独占锁，只允许自己读和写，其他事务不能读也不能写</p><h2 id="代码题">3.2. 代码题</h2><p>1.byte[]-&gt;String</p><p>2.Date-&gt;String（某格式）</p><p>3.SimpleDateFormat</p><p>4.BlockingQueue,offer(A,B,C)</p><p>5.List-&gt;数组</p><h1 id="微众银行">4. 微众银行</h1><p>1.进程与程序的区别</p><p>程序：静态的，可执行文件，一系列指令的集合</p><p>进程：动态的，是程序的执行过程。由程序段、相关数据段和PCB构成。</p><p>一个程序有多个进程，而一个进程只能有一个程序？</p><p>2.定义内部类</p><img src="/2020/03/26/2020%E7%AC%94%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212174058275.png" class title="image-20220212174058275"><p>3.yield()</p><p>是Thread实例的一个方法，用于暂停当前正在执行的线程对象，并执行其他线程。</p><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p><p>4.B&#x2F;S模式下，加密传输的协议</p><p>https</p><p>5.表的创建</p><p>列完整性又称实体完整性？</p><p>用存储过程保证数据完整性？</p><p>6.背包问题，贪心算法的时间复杂度</p><p>O(nlogn)</p><p>7.Spring下默认的bean的设计模式</p><p>单例模式（公用一个实例，提高性能）</p><p>8.泛型</p><p>public &lt;T super List&lt;?&gt;&gt; void fun(T t){} 错误</p><p>public &lt;T extends List&lt;?&gt;&gt; void fun(T t){} 正确</p><p>9.socket传文本文件</p><p>10.并查集</p><p>并查集的数据结构：father[i] 表示第i个结点的父结点</p><p>并查集的操作：查询（查询某个结点的根结点），合并（合并两个结点所在的独立集合）</p><p>11.静态存储分配语言满足的条件</p><p>12.字节流读文件用什么类</p><p>FileInputStream</p><h1 id="联通广州软件研究院">5. 联通广州软件研究院</h1><p>1.小型用户数据库</p><p>2.网页分三层</p><p>3.CSS属性区分大小写吗？</p><p>4.any,all子查询</p><h1 id="交通银行">6. 交通银行</h1><p>1.内聚等级</p><p>2.实体完整性</p><p>3.不是bean的作用域</p><p>4.双绞线，万兆以太网</p><p>5.ASCII码表示字符个数</p><p>128个</p><p>6.ping的协议是什么？</p><p>ICMP协议（Internet Control Message Protocol）控制报文协议，位于网络层</p><p>7.SET协议</p><p>8.分组交换</p><p>9.TCP和UDP支持一对一吗？</p><p>10.不能在数据中存数据的？裸设备？</p><p>11.敏捷开发，出现新需求怎么办？</p><p>12.SOA基本特征</p><p>13..class文件目录</p><p>14.风险与风险概率、影响的关系</p><p>15.aix</p><p>16.锁定表，允许读，是什么锁？</p><p>17.密码学</p>]]></content>
    
    
    <summary type="html">2020笔试题总结，包括招商银行、格力、招银网络科技、微众银行、联通广州软件研究院、交通银行</summary>
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>2020面试题总结</title>
    <link href="http://example.com/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-25T07:26:14.000Z</published>
    <updated>2022-10-31T10:25:40.007Z</updated>
    
    <content type="html"><![CDATA[<p>你有什么问题要问吗？</p><ul><li>贵公司对新加入公司的员工有没有什么培训项目</li><li>贵公司的晋升机制是什么样的？</li><li>入职后参与的项目的情况</li><li>我这次面试还有什么地方有待改进？</li><li>…</li></ul><h1 id="字节跳动">1. 字节跳动</h1><p>1、抽象类与接口区别</p><ol><li>抽象类：<ol><li>abstract修饰</li><li>可以有构造方法</li><li>任意成员变量</li><li>任意方法</li><li>用于继承，一个类只能继承一个抽象类</li><li>子类可以是抽象类</li></ol></li><li>接口<ol><li>interface修饰</li><li>没有构造方法</li><li>成员变量必须是public static final，且需要初始化</li><li>只有抽象方法public abstract</li><li>用于实现，一个类可实现多个接口</li><li>子类（实现类）必须实现接口所有抽象方法</li></ol></li></ol><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C5E.tmp.png" class title="img"><p>2、抽象类与接口的选择</p><ol><li>使用抽象类<ol><li>经常修改方法或添加方法</li><li>需要提供默认行为</li></ol></li><li>使用接口<ol><li>功能基本不变</li><li>使用多继承（多实现）</li></ol></li></ol><p>3、为什么要面向抽象编程（为什么要用抽象类）？</p><ul><li>抽取相同属性，共有行为</li><li>便于扩展，实现多态</li></ul><p>4、引用和指针的区别</p><ol><li>引用<ol><li>变量的别名（不是拷贝，用于参数时提高效率）</li><li>直接访问变量，相当于对原变量直接操作</li><li>必须声明的时候就初始化（即一定不为空）</li><li>可以用const修饰</li></ol></li><li>指针<ol><li>指向变量的内存地址 int *p; int a; p&#x3D;&amp;a;</li><li>间接访问变量，通过地址访问变量</li><li>可以为空指针</li><li>可以用const修饰，指针常量，表示该指针不可变（地址不可变）</li></ol></li></ol><h1 id="华为">2. 华为</h1><p><strong>一面</strong></p><ol><li>找最长单词的元音字母，去重并排序</li><li>项目，计网</li></ol><p><strong>二面</strong></p><ol><li><p>计算机网络，协议</p></li><li><p>项目</p></li><li><p>java的类实例化会不会失败？</p><p>按理说不会失败，类有默认的空构造函数，实例化时会调用，抽象类就不能实例化</p></li><li><p>找最长回文子串</p></li><li><p>抽象类和接口不能实例化</p></li></ol><p><strong>三面</strong></p><ol><li>项目，职责，遇到突发事件能力</li><li>笔试分数？</li><li>网络部分知识，语言java，c++</li></ol><h1 id="广发银行">3. 广发银行</h1><p><strong>一面</strong></p><ol><li><p>项目职责</p></li><li><p>SpringMVC</p></li><li><p>MyBatis，用#还是$符号？</p><ol><li><p>#{a} 自动把a的值变为字符串，即加上了’’；预编译；防止sql注入</p><p>如id的值为2，则select * from admin where id&#x3D;#{id}-&gt; select * from admin where id&#x3D;’2’</p></li><li><p>${a} 不会将a当做字符串处理，原来值是什么就是什么</p><p>如id的值为2，则select * from admin where id&#x3D;#{id}-&gt; select * from admin where id&#x3D;2</p><p>如id的值为id，可以用于select * from admin order by ${id}-&gt; select * from admin order by id</p></li></ol><p>一般能用#{}就用这个</p></li><li><p>session</p></li><li><p>分布式</p><p>一句话概括：分布式就是我们把整个系统拆分成不同的服务，然后将这些服务放在不同的服务器上减轻单体服务的压力，提高并发量和性能，便于系统的管理与维护。</p><p>比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p></li><li><p>分布式系统设计：</p><ol><li>中心化设计：<ul><li>节点分为两个角色：“领导”和“工人”</li><li>“领导”负责分发任务和监督“工人”工作，“工人”负责完成相应任务</li><li>问题：1.“领导”如果宕机怎么办？2.“领导”的能力不足怎么办？</li><li>解决：1.使用主备“领导”，热备或冷备，自动切换或主动切换2.更新优化硬件或软件</li></ul></li><li>去中心化设计：<ul><li>各个节点之间低位平等，每个节点既是“领导”又是“工人”</li><li>去中心化不是不要中心，而是节点自动选择中心，集群自发选举“领导”来主持工作</li><li>问题：1.脑裂问题：一个集群由于网络故障，被分为两个互不连通的独立集群，如果它们同时工作，将会导致数据不同步的问题</li><li>解决：1.独立集群中规模较小的可以停止运行，只需规模最大的保持运行</li></ul></li></ol></li><li><p><strong>Dubbo</strong></p><p>高性能、轻量级开源Java RPC框架，是分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p></li><li><p><strong>RPC</strong></p><p>Remote Procedure Call—远程过程调用，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</p></li><li><p>java基本数据类型，常用的类</p></li></ol><h1 id="百度">4. 百度</h1><p><strong>一面</strong></p><ol><li><p>文件类型，按用户观点来分类？</p><ol><li>按用途分类：<ul><li>系统文件：由系统软件构成的文件，大多只允许用户调用，不允许用户读和改</li><li>库文件：允许用户调用，不许更改</li><li>用户文件：用户的源代码、目标文件、可执行文件或数据</li></ul></li><li>按结构分类：<ul><li>结构文件（记录）</li><li>无结构文件（字节流）</li></ul></li><li>按形式分类：<ul><li>源文件：源程序和数据构成的文件</li><li>目标文件：源文件经过编译行程的，但尚未经过链接程序链接的目标代码构成的文件（属于二进制文件）</li><li>可执行文件：目标代码经过链接程序连接后形成的文件</li></ul></li></ol></li><li><p>快排</p></li><li><p>TCP&#x2F;UDP</p></li><li><p>TCP的建立与释放</p></li><li><p>学生会、班长，感想、收获</p></li></ol><p><strong>二面</strong></p><ol><li><p>计算机系统中的堆和栈，变量保存在哪？</p><p>栈（stack）：系统自动分配和回收，连续存储（速度快），保存局部变量</p><p>堆（heap）：程序员自己分配（如malloc&#x2F;new）和回收（如free&#x2F;delete），程序结束时系统也会回收，不连续存储（速度慢），程序员自己设定变量</p></li><li><p>死锁，资源</p><p>多个进程竞争同一个不可剥夺的资源而出现互相等待的局面（如打印机、磁带机资源）</p><p>进程间彼此等待对方发送消息也会造成死锁</p><p>死锁四个必要条件：互斥条件、不可剥夺条件、请求并保持条件、循环等待条件</p></li><li><p>简单介绍一下动态规划，为什么它速度快？</p><p>动态规划是用来解决最优化问题的方法，它将大问题划分为多个子问题，然后能保存已经计算过子问题的答案，并用这些答案再得出新的子问题答案，最终求得最优解，避免了大量的重复运算，节约时间。</p></li><li><p>索引，怎么维护索引？</p><p>索引的数据结构有两种，一种是B+树，一种是哈希表</p><p>当表中有大量增、删、改的时候，需要维护索引，维护索引的方法：1.重构索引 2.合并索引</p></li></ol><h1 id="省农信">5. 省农信</h1><ol><li>项目难题，如何解决</li><li>第一份工作，为什么选择来我们这里</li><li>职业规划</li><li>java与c++的区别，类的继承方面</li></ol><h1 id="广州光锥元">6. 广州光锥元</h1><ol><li><p>java面向对象如何理解</p><p>面向对象的三大特征：封装、继承、多态</p></li><li><p>如何获取栈中最大值，O(1)</p><p>用另一个栈存储当前出现过的最大值</p></li><li><p>如何检测链表是环</p><p>如果有拓扑排序则表明不是环，如果没有则是环</p></li><li><p>n*n的01矩阵中，找k*k矩阵中1最多的个数</p></li><li><p>排序，冒泡（如何算时间复杂度），快排</p></li><li><p>使用过哪些集合类，ArrayList，LinkedList区别</p></li><li><p>HashMap是什么，Hash是什么，线性探测</p></li><li><p>简述索引，什么时候建索引，聚簇索引和非聚簇索引</p><p>索引就是用于快速查询的数据结构，索引的数据结构一般为B+树</p><p>需要经常搜索的字段应该建立索引</p><p>聚簇索引：索引结构和数据放在一起，叶子结点存放的是整行数据</p><p>非聚簇索引：索引结构和数据分开放，叶子结点存放的是主键</p></li><li><p>什么是事务，事务隔离级别</p><p>事务的四大特性：</p></li></ol><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C5F.tmp.jpg" class title="img"><ul><li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p>事务隔离级别：</p><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C60.tmp.jpg" class title="img"><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C61.tmp.jpg" class title="img"><ol start="10"><li>设计模式，单例模式</li></ol><p>饿汉式：编译的时候就初始化实例（private static final）</p><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C62.tmp.jpg" class title="img"><p>懒汉式：运行时创建实例，如果是并发操作则应该上锁</p><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C63.tmp.jpg" class title="img"><p>如果并发创建单例，应该如何防止出现问题？</p><p>使用<strong>双重校验锁</strong></p><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/image-20220212190746427.png" class title="image-20220212190746427"><h1 id="深圳四方精创">7. 深圳四方精创</h1><p>工资情况</p><ol><li>实习期（入职-拿毕业证）：3000，免住房</li><li>试用期（3-6个月）：4800</li><li>正式：7000-7500税前，年终奖1-1.3倍基本工资（3000）</li><li>加班：周末2倍，节假日3倍</li></ol><h1 id="深圳快造">8. 深圳快造</h1><p>问题：</p><ol><li>归并排序，稳定性</li><li>快排</li></ol><p>职位：做CAM（computer act machine），计算机图形学</p><p>找工作（个人角度）：</p><ol><li>成长（公司是否有成长性，是否能真正学到东西）</li><li>兴趣（自己的兴趣点在哪）</li><li>薪资：应该比自己产出的价值低一些，</li><li>舒适（现在不用考虑舒适的问题，现在是拼命的年纪）</li></ol><p>公司角度：</p><ol><li>是否聪明，是否有能力</li><li>薪资，如何两个人成长性相同，那么肯定要薪资低的</li></ol><p>缺点：</p><ol><li><p>考研目标不明确，到底自己为什么要考研？</p><p>我为什么要考研呢？跟风？应该是听了周围人的意见，他们说现在本科生是大白菜，不好找工作，有了研究生文凭会容易一些。说到底还是为了找工作，找更好的工作，工资更高的工作而已。还有就是去一个更好的学校，体验一下另外一种氛围，然后结识更优秀的人吧。</p></li><li><p>考研失利后没有很好地反思</p><p>为什么没考好？可能是考试时候心态不稳定，发挥失常。明明之前模拟测试的时候分数不低，但到最终考场，水平会大打折扣。刷的题目不够多，然后不能融会贯通，做数学的时候感觉跟之前做的都不是一种卷子，很多地方都不知道怎么入手。不够拼命，在最后复习阶段，我仍然像一般复习那样，到最后关头有些松懈了，没有一直紧绷着神经。</p></li><li><p>竞赛没有含金量，没有亮点</p><p>美国数学建模大赛还是有含金量的，H奖大概在前15%</p></li></ol><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C74.tmp.jpg" class title="img"><ol start="4"><li><p>不能证明自己的能力</p><p>因为没有参加富有含金量的比赛，</p></li></ol><p>如何证明自己有能力？</p><h1 id="工商银行软件">9. 工商银行软件</h1><ol><li>单例模式</li><li>对工商银行软开的看法？</li><li>如果你很努力了，但绩效考核还是很差，你会怎么做？</li><li>如果上司安排给你无法完成的工作量，你会怎么做？</li></ol><h1 id="联通广州研究院">10. 联通广州研究院</h1><p><strong>一面</strong></p><ol><li>SpringBoot</li><li>SpringMVC过程</li><li>Java原生于Spring的区别</li><li>你有什么缺点</li><li>有没用过分布式</li><li>路由器和交换机的区别</li></ol><h1 id="招银网络科技">11. 招银网络科技</h1><p><strong>一面</strong></p><ol><li>JVM中的内存区域，内存泄漏的情况</li></ol><ul><li><p>线程共享：堆（新生代、老生代、永生代-&gt;元空间（JDK1.8））、方法区-&gt;元空间（JDK1.8，元空间放在直接内存中）、直接内存</p></li><li><p>线程私有：程序计数器、虚拟机栈、本地方法栈</p></li><li><p>堆：存放几乎所有对象，程序员自己分配</p></li><li><p>栈：存放局部变量，系统自动分配和回收</p></li><li><p>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p></li><li><p>常量池：JDK1.7在方法区中，JDK1.8在堆中</p></li><li><p>内存泄漏：一个程序不再被使用，但仍然在内存中占用内存空间</p></li><li><p>内存溢出：当程序申请内存时，系统没有足够内存提供使用，即你要使用的内存空间&gt;系统给你分配的内存空间</p></li><li><p>JVM虽然有GC自动回收垃圾，但有些情况会让JVM误认为对象还在引用，从而不回收，导致内存泄漏或溢出</p><p>  内存泄漏的情况：</p></li><li><p>递归过深，栈进得太深</p></li><li><p>new的对象大小超过了内存容量</p></li><li><p>静态集合类：其生命周期和程序一样，在程序结束之前都无法被释放</p></li><li><p>各种连接：</p></li><li><p>变量不合理的作用域</p></li><li><p>内部类持有外部类</p></li><li><p>改变哈希值</p></li></ul><ol start="2"><li>Java类初始化的情况，什么时候类会初始化，如new的时候，还有其他吗？</li></ol><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C75.tmp.jpg" class title="img"><ol start="3"><li>HashSet和TreeSet区别</li><li>HashMap中，简述哈希冲突，以及解决哈希冲突的方法</li><li>冒泡排序，看一下编码风格和编码规范</li><li>线程阻塞后，是否会阻塞进程（多处理机）</li></ol><p>线程模型：</p><p>(1) 多对1用户级线程模型</p><ul><li>线程的创建、调度、同步，由所属进程的用户空间线程库实现。</li><li>用户态线程，对内核几乎是透明的（许多操作不需要内核接管）</li><li>但线程总要有一些操作经过内核，比如系统调用。</li><li>不需要频繁的内核态&#x2F;用户态切换，处理速度非常快。</li><li>该模式下，当进程的某个线程，系统调用（比如I&#x2F;O）阻塞时，该进程也会阻塞。</li><li>原因：该模式下，进程的所有线程，都对应一个内核调度实体（KES），并且内核不知道这个进程有哪些线程。KES无法将其他线程，调度到其他处理器上。该进程（所有的线程）被阻塞，直到本次系统调用（比如I&#x2F;O）结束。</li></ul><p>(2) 1对1内核级线程模型（Linux一般使用这个模型）</p><ul><li>每个用户线程都对应一个的内核调度实体。</li><li>内核会对每个线程进行调度，可以调度到其他处理器上。某个线程阻塞并不会导致整个进程阻塞</li><li>线程每次操作会在用户态和内核态切换。</li><li>线程数量过多时，对系统性能有影响。</li></ul><p>(3) 多对多两级线程模型</p><ul><li>每个用户线程拥有多个内核调度实体</li><li>多个用户线程也可以对应一个内核调度实体</li><li>实现该模型非常复杂。</li></ul><p>在单处理机上，都会阻塞，因为只允许一个进程使用</p><p><strong>二面</strong></p><p>编程：</p><ol><li>输入一个日期，返回上个月月末日期</li></ol><p>问题：</p><ol><li>多线程方面</li><li>java的锁机制</li><li>印象最深的项目，做过的功能中选一个讲解</li></ol><p><strong>hr面</strong></p><ol><li>考研</li><li>为什么面了这么多公司，没有offer？</li><li>要有自己的看法，自己的理解，去跑项目，模仿开源项目</li></ol><h1 id="深圳快造-1">12. 深圳快造</h1><p><strong>一面</strong></p><p>编程：</p><ol><li>字符串转数值</li><li>最长回文子串</li></ol><p>问题：</p><ol><li>Map如何实现并发？</li><li>HashMap</li><li>红黑树</li><li>垃圾回收GC</li><li>多线程</li></ol><p><strong>二面</strong></p><ol><li><p>java为什么单继承</p><p>多继承，如果多个父类有相同的方法，那么子类就不知道执行哪个，java为了简单就抛弃了多继承</p></li><li><p>两个堆分别有x和y个石头，A和B轮流拿若干个石头，A先手，A有稳赢的方法吗？</p></li><li><p>子类实例化后，父类的私有变量在这个实例中吗？</p><p>子类拥有父类的私有变量，但不能访问</p></li><li><p>01背包问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]表示前i个物品放在容量为j的背包中的最大价值</span><br><span class="line">要放第i个物品时</span><br><span class="line">如果第i个物品的重量大于j，则不能放入：</span><br><span class="line">dp[i][j]=dp[i-1][j];</span><br><span class="line">如果第i个物品重量不大于j，则有两种情况（放或不放），取这两种中的最大值：</span><br><span class="line">Math.max(dp[i-1][j-w[i]]+v[i],dp[i-1][j]);//放的时候需要回到j-w[i]的容量，让其刚好放进去</span><br></pre></td></tr></table></figure></li><li><p>内存中的堆和栈</p><p>堆：存放几乎所有对象，程序员自己分配</p><p>栈：存放局部变量，系统自动分配和回收</p></li><li><p>main方法中的局部变量放在哪里？</p><p>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><p>main方法是静态方法，其中的变量就是静态变量</p><p>静态变量存放在方法区中</p></li></ol><h1 id="腾讯测试开发">13. 腾讯测试开发</h1><p><strong>一面</strong></p><p>编程题：</p><p>(1)<br>n天<br>work[n] 1表示公司开门，0表示公司关门<br>sport[n] 1表示健身房开门，0表示健身房关门<br>只有在开门的时候才能工作或锻炼<br>不能连续两天工作或锻炼<br>求最少休息多少天？</p><p>输入：<br>4<br>1 1 0 0<br>0 1 1 0</p><p>输出：<br>2</p><p>(2) 解压缩字符串</p><p>[3|ABC]-&gt;ABCABCABC</p><p>HG[3|B[2|CA]]F-&gt;</p><p>(3) 翻转数列</p><p>n个数(1至n)，然后m表示每m个数符号翻转一次，初始符号为’-’，n%2m&#x3D;&#x3D;0</p><p>输入：</p><p>8 2</p><p>-1,-2,3,4,-5,-6,7,8</p><p>输出：</p><p>8</p><p>问题：</p><ol><li><p>介绍同步和异步的概念</p><p>同步：A发送消息给B，A停止并等待B的响应，B响应后，A才能开始工作</p><p>异步：A发送消息给B，A可以继续工作，B响应后，A处理完B的事情再继续工作</p></li><li><p>SpringMVC的5个组件</p></li></ol><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C76.tmp.jpg" class title="img"><p>(1) DispatcherServlet （前端控制器, 处理请求的入口）</p><p>(2) HandlerMapping （映射器对象, 用于管理url与对应controller的映射关系）</p><p>(3) Interceptors（拦截器,实现请求响应的共性处理）</p><p>(4) Controller （后端控制器, 负责处理请求的控制逻辑）</p><p>(5) ViewResolver（视图解析器,解析对应的视图关系：前缀+view+后缀）</p><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C77.tmp.png" class title="img"><img src="/2020/02/25/2020%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/wps6C78.tmp.jpg" class title="img"><p><strong>1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供（重要）</strong></p><p>作用：Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</p><p><strong>2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p><p>作用：根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器（Controller），SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><strong>3、处理器适配器HandlerAdapter</strong></p><p>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><p><strong>4、处理器Handler(需要工程师开发)</strong></p><p>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p><p><strong>5、视图解析器View resolver(不需要工程师开发),由框架提供</strong></p><p>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） 。View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p><strong>6、视图View(需要工程师开发)</strong></p><p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p><blockquote><p>注意：处理器Handler（也就是我们平常说的Controller控制器）以及视图层view都是需要我们自己手动开发的。其他的一些组件比如：前端控制器DispatcherServlet、处理器映射器HandlerMapping、处理器适配器HandlerAdapter等等都是框架提供给我们的，不需要自己手动开发。</p></blockquote><ol start="3"><li><p>SpringMVC的优点</p></li><li><p>Controller是否是单例</p></li><li><p>用过多线程吗？</p></li><li><p>垃圾回收机制</p></li><li><p>Lock和synchronized</p></li><li><p>Collection接口</p></li><li><p>List和Map区别</p></li><li><p>ArrayList和LinkedList</p></li><li><p>项目做的工作和难点</p></li><li><p>java反射是什么，几种反射的方法</p><p>反射：反射机制是一种动态获取信息和动态调用对象的方法的功能。在java运行期间，对于任意一个类能获取其的方法和属性，对于任意一个对象能够调用其方法和属性。</p></li></ol><p>4种反射方法：</p><ol><li><p>Class.forname(“包名.类名”)</p></li><li><p>类.class属性</p></li><li><p>实例.getClass()方法</p></li><li><p>ClassLoader类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = main实例.getClass().getClassLoader();</span><br><span class="line">Class c = classLoader.loadClass(className);</span><br></pre></td></tr></table></figure></li></ol><h1 id="深圳萨摩耶互联网金融服务有限公司">14. 深圳萨摩耶互联网金融服务有限公司</h1><ol><li><p>springMVC</p><ol><li>配置文件注入方法，数据保存在什么地方</li><li>bean的生命周期</li><li>入口类</li><li>mapper有哪几种，除了get&#x2F;post 还有其他吗？get和post的区别</li></ol></li><li><p>mybatis多少级缓存？</p></li><li><p>Dubbo,SpringCloud</p></li><li><p>HashMap，HashTable，ConcurrentHashMap区别</p></li><li><p>索引的数据结构</p></li></ol><p>Http请求类型</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">2020面试题总结，面试的公司包括字节、华为、广发、百度、省农信、广州光锥元等</summary>
    
    
    
    <category term="面经" scheme="http://example.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>本科项目总结</title>
    <link href="http://example.com/2020/02/25/%E6%9C%AC%E7%A7%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/02/25/%E6%9C%AC%E7%A7%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-25T05:00:55.000Z</published>
    <updated>2022-03-01T07:05:21.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《仿当当网》">1. 《仿当当网》</h1><h2 id="职责">1.1. 职责</h2><p>管理团队，监督开发进度，主要做前端的功能，如制作主页、书籍显示、查找、详情、评论等</p><p>帮助后台改进其功能，整合前后端并修改完善代码</p><h2 id="重点">1.2. 重点</h2><p>ThinkPHP框架，修改应用配置文件config.php，数据库配置文件database.php（连接本地数据库）</p><p>MySQL数据库，Apache24 （Web服务器，httpd.conf配置IP地址、端口)</p><p>apache解析静态页面html</p><p>controller（控制器，逻辑实现），model（模型，连接数据库的表），view（视图，前端网页）</p><h2 id="难点">1.3. 难点</h2><p>ajax局部刷新（在script中写逻辑实现，操控元素的局部变化）</p><p>如何快速查找表，用关联，用索引</p><p>安全性问题（get，post）</p><p>某些功能实现，如分页显示、滚动播放、上传图片等</p><h2 id="突出点">1.4. 突出点</h2><p>ThinkPHP框架，配置简单，开发快速。</p><h1 id="《电影网》">2. 《电影网》</h1><h2 id="职责-1">2.1. 职责</h2><p>SSM项目框架的搭建，个人主页的设计（个人信息显示、密码修改和注册登录），</p><p>影评页面的设计（发布影评、影评显示、点赞等），项目整合与完善。</p><h2 id="重点-1">2.2. 重点</h2><p>前端是在模板的基础上修改而来</p><p>SSM(Spring、SpringMVC、Mybatis)环境搭建</p><p>数据库：MySQL</p><p>服务器：apache（静态解析html，简单，快速）+</p><p>tomcat（用java编写，支持Servlet，动态解析jsp&#x2F;php等）</p><h2 id="难点-1">2.3. 难点</h2><p>一开始搭建环境出很多问题，没有用maven管理jar包，导致很多缺包的情况</p><p>mybatis中mapper.xml（执行数据库命令）对mapper.java的映射，想添加一种数据库操作，就必须修改这两个文件，这样不符合开闭原则</p><p>抽象方法与具体方法分离，面向抽象编程</p><p>配置文件问题，不懂配置的属性</p><p>高并发点赞怎么办（如何保证线程安全，且性能高）：如果是单击服务，则用 原子类Atomic（如果用加锁，速度会慢）；如果是集群服务，用redis</p><p>下拉加载长评：先初始化显示5个，设置滚动事件，获取整个页面高度、屏幕高度和滚动条向下滚动距离，来计算出是否浏览完，然后再显示后面的</p><p>长文String的回车不会显示：需要转换成html的格式，即把回车变为<br>才能在jsp上显示</p><h2 id="突出点-1">2.4. 突出点</h2><p>Mybatis：sql语句写在xml中，与程序代码解耦，通过提供DAO层，将业务逻辑和数据访问逻辑分离，提高可维护性</p><h1 id="《函数画图》">3. 《函数画图》</h1><h2 id="职责-2">3.1. 职责</h2><p>算法设计和图形处理。包括多项式计算的实现和函数曲线画图等</p><h2 id="重点-2">3.2. 重点</h2><p>表达式求值，逆波兰算法（将中缀表达式转换为后缀表达式），再遍历后缀表达式，遇到数字则加入数字栈，遇到操作符（需要判断是单目还是双目），再弹出对应的数字并计算，将计算结果再入栈，最后得出结果</p><p>描点画图</p><h2 id="难点-2">3.3. 难点</h2><p>图形缩放流畅度</p><p>计算符号的优先级设计</p><p>大数值的运算和显示（用字符串来记录）</p><h2 id="突出点-2">3.4. 突出点</h2><p>画函数图</p><h1 id="《空竹飞一飞》">4. 《空竹飞一飞》</h1><h2 id="职责-3">4.1. 职责</h2><p>负责游戏主要编程，如空竹、绳子主要逻辑，道具效果，摄像机移动，统计得分和场景转换等功能。</p><h2 id="重点-3">4.2. 重点</h2><p>Cocos Creator使用，项目框架</p><p>启用物理引擎，实现自由落体的效果</p><p>拉动绳子和弹跳效果：鼠标关节实现拖动，距离关节计算初速度向量</p><p>碰撞效果：物理碰撞，形状碰撞</p><p>摄像机移动（高度会不断上升，这样不知道会不会到达高度的界限）</p><p>各种道具效果</p><h2 id="难点-3">4.3. 难点</h2><p>优化问题：在手机差的情况下，流畅度较低，可能是一些逻辑循环或者线程太多导致的，想要优化，但却难以下手</p><p>摄像机跟踪：游戏中摄像机跟踪是每一帧都判断执行，所以这个可能是导致游戏掉帧的原因之一（可能用背景移动相对移动会更好吧）</p><p>游戏难度设计：如何设计更好的游戏体验，我们根据游戏得分进行分段设计游戏难度，总共分为三个阶段，越高分难度越大，绳子之间间隔越大，也就越考验用户的角度和力度把握</p><h2 id="突出点-3">4.4. 突出点</h2><p>拉动并弹射</p>]]></content>
    
    
    <summary type="html">仿当当网、电影网、函数画图微信小程序、空竹飞一飞微信小游戏</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
</feed>
